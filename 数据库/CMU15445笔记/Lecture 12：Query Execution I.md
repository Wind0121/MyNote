# Processing Models
DBMS 处理模型定义了系统如何执行查询计划。它指定了查询计划的执行方向，以及在执行过程中操作符之间传递什么样的数据。

## Iterator Model（迭代器模式）
迭代器模型，也称为 Volcano 或 Pipe line 模型，是最常见的处理模型，几乎每个(基于行的)DBMS 都使用它。

原理如下：
- 每个操作符实现一个 Next 函数
- 查询计划中的每个节点在它的子节点上调用 Next，直到到达叶子节点，叶子节点开始发出元组到它们的父节点进行处理
- 在检索下一个元组之前，每个元组尽可能地向上处理计划
	- 在每次调用 Next 时，如果没有更多的元组要发出，操作符要么返回**单个元组**，要么返回 **null 标记**
![[Pasted image 20231204193021.png]]

有些操作符会阻塞，直到子进程发出他们所有的元组。此类操作符的例子包括Join、subqueries 和排序 (ORDER BY)。这样的操作符被称为管道断路器(pipeline breaker)

优势：可以很方便地控制输出
劣势：有可能阻塞较长时间

## Materialization Model
物化模型是迭代器模型的特殊化，其中每个操作符一次性处理其**所有输入**，然后一次性发出其**所有输出**

每个查询计划操作符都实现了一个输出函数：
- 操作符一 次性处理来自其子节点的所有元组
- 此函数的返回结果是 operator 将发出的所有元组
![[Pasted image 20231204193030.png]]

这种模型更适合OLTP模式的数据库（查询少，修改多），因为每次返回的数据量会比较少，且处理起来比较快。不适合OLAP模式的数据库（查询多，数据量大），因为每次查询都需要等待所有数据返回

## Vectorization Model
向量化模型是一个中间派。前面的迭代器模型和物化模型分别代表了两个极端，而向量化模型作为中间派，每次返回的一个batch的元组量。
- 向量化模型方法非常适合必须扫描大量元组的 OLAP 查询，因为对 Next 函数的调用较少
- 向量化模型允许操作符更容易使用向量化(SIMD)指令来处理批量的元组

![[Pasted image 20231204193216.png]]

## 处理方向
- 从上往下
	- 从根源开始， 将数据从儿子“拉 ”到父母
	- 元组总是通过函数调用传递
- 从下往上
	- 从叶子节点开 始，将数据从儿子 “推送” 到父母
	- 允许严格控制管道中的缓存/寄存器

# Access Methods
访问方法是 DBMS 访问表中存储的数据的方式。一般来说，存取模型有两种方法：
- 要么从表中读取
- 要么从索引中读取

## 顺序扫描
顺序扫描操作符遍历表中的每一页，并从缓冲池中检索它。当扫描遍历每一页上的所有元组时，它会对谓词进行评估，以决定是否将元组发送给下一个操作符（说白了就是全表扫描）

顺序表扫描几乎总是 DBMS 执行查询时效率最低的方法。有一些优化方法可以帮助提高顺序扫描的速度：
![[Pasted image 20231204194829.png]]

关于Data Skipping：
1. 近似查询：对整个表的采样子集执行查询以产生近似结果
2. Zone Map：预先计算页面中每个元组属性的聚合。然后， DBMS 可以通过首先检查 Zone Map 来决定是否需要访问某个页面。
	- Zone Map在云数据库系统中特别有价值，因为通过网络进行数据传输需要更大的成本

## 索引扫描
在索引扫描中， DBMS 选择一个索引来查找查询所需的元组。

在DBMS选择索引的过程中，涉及许多因素：**（查询优化会讲）**
- 索引包含什 么属性
- 查询引用哪些属性
- 属性的值域
- 谓词组合
- 索引是否有唯一键或非唯一键

多索引扫描：
通过对谓词的多个索引进行筛选，然后再取交集/并集，从而快速筛选
![[Pasted image 20231204200141.png]]

# Modification Queries
- 修改数据库的操作符(INSERT、UPDATE、DELETE)负责检查约束和更新索引。
- 对于 UPDATE/DELETE，子操作符传递目标元组的 Record id，并且必须跟踪以前看到的元组

![[Pasted image 20231204200430.png]]


# Expression Evaluation
感觉没什么用

