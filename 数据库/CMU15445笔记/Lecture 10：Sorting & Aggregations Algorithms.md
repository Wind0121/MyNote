# 排序
## 必要性
- 关系模型下，表元组默认没有特定顺序
- ORDER BY、DISITNCT、GROUP BY都可能用到排序
- 内存装不下大量的表数据，需要使用外部排序算法，即依靠磁盘

## 2-way归并算法
就是最经典的2路归并，只不过是需要依靠磁盘进行操作的。
![[Pasted image 20231203192348.png]]
内存只需要三个page，两个page从磁盘中读取需要排序的page，一个page用于排序好的中间结果输出。

问题在于内存通常不止三个page的大小，而这种算法只能利用三个page，这是对内存的浪费。

## 多路归并算法
内存有多大就用多大，假设内存大小为B page：
- 第一轮每次读B个page，然后内部排序
- 接下来每次读B - 1个page，留下一个作为输出page
![[Pasted image 20231203192636.png]]

## B+树排序
B+树这种数据结构天然具有排序性质，我们可以直接找到叶子节点，然后利用兄弟指针找到下一个叶子节点。
![[Pasted image 20231203192808.png]]

# 聚集
查询计划中的聚合操作符将一个或多个元组的值折叠为单个标量值。有两种实现聚合的方法：(1)排序和(2)哈 希

## 排序
- DBMS 首先根据 GROUP BY 键对元组进行排序
- 如果所有东西都能放入缓冲池，它可以使用内存排序算法
- 如果数据的大小超过内存，它可以使用外部归并排序算法
- 然后，DBMS 对排序后 的数据执行顺序扫描，以计算聚合

## 哈希
- 在计算聚合时，哈希在计算上比排序更便宜
- DBMS 在扫描表时填充一个临时哈希表。对于每条记录， 检查哈希表中是否已经有一个条目，并执行适当的修改
- 如果哈希表的大小太大，内存无法容纳，那么 DBMS 必须将其溢出到磁盘。实现这一过程分为两个阶段：
	1. 分区：使用哈希函数 h1 根据目标哈希键将元组分割为磁盘上的分区。这将把所有匹配的元组放入同一个分区
	2. Re-Hash：对于磁盘上的每个分区，将其页面读取到内存中，并基于第二个哈希函数 h2 构建内存中的哈希表。遍历这个哈希表的每个桶，将匹配 的元组聚集在一起，计算 聚合
- 在 Re-Hash 阶段 ，DBMS 可以存储形式为(GroupByKey->RunningValue) 的键值对来进行计算

