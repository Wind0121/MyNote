# 简介
![[Pasted image 20231108163453.png]]
在执行引擎和磁盘之间需要有一个内存缓冲池来缓存需要操作的页面，这样能尽可能减少对磁盘的读写，从而提高效率。
# 缓冲池（buffer pool）
缓冲池是从磁盘读取的页面的内存缓存 。它本质上是在数据库内部 分配的一个大内存区域， 用于存储从磁盘读取的页面。

缓冲池的内存区域被组织成固定大小的页面数组。 每个数组条目称为一个帧。

![[Pasted image 20231108163812.png]]

## 缓冲池元数据（Meta Data）
缓冲池必须维护一定的元数据，以便有效和正确地使用缓冲池中的数据。

**Page Table**
就是一个哈希表，key为page id，value为page在缓冲池中的位置。这样就可以快速定位需要的page。

**Dirty Flag**
由线程在修改页面时设置。表明存储管理器必须将该页写回磁盘。

**Pin/Reference Counter**
表示正在使用该页面的线程数。如果该值大于0，则不能将该page驱逐出缓冲池。

# Locks vs Latches
- Locks：高级别的，逻辑上的锁。一般用于表示锁住一个事务需要用到的表（Table）、数据库等。
- Latches：低级别的，实际上的锁。一般用于锁住具体的数据结构等。也可以称为mutex。

# 缓冲池优化
## Multiple Buffer Pools（多缓冲池）
DBMS 可以为不同的目的维护多个缓冲池 (即每个数据库缓冲池，每个页面类型缓冲池) 。然后 ，每个缓冲池可以采用适合其内部存储的数据的本地策略。 

## Pre-Fetching（预抓取）
通过预判事务需要用到的page，提前将该page缓存到缓冲池中。一般有两个应用场景：
- 顺序扫描：由于知道事务需要顺序扫描，可以提前驱逐已经用过的page，然后将接下来几个page加载到缓冲池中。
- 索引查找：由于知道事务需要抓取的page的索引，提前将page加载到缓冲池中。

## Scan Sharing（共享扫描）
看以下例子：一个事务需要扫描一块区域，然后另一个事务也要扫描同一个区域，就会先跟着前一个事务扫描，这样就节省了缓冲池的空间。然后等前一个事务结束，再接着扫描第二个事务没扫描的page。
![[Pasted image 20231108164734.png]]

## Buffer Pool Bypass（缓冲池旁路）
查询时不使用缓冲池，而是直接开拓一块内存，用完就直接释放，这就叫**旁路**
- 如果操作符需要读取磁盘上连续的大量页面序列，这将很好地工作。 
- 缓冲池旁路也可以用于临时数据 (排序、连接)

# OS Page Cache（操作系统缓冲池）
大多数DBMS使用直接I/O（实际上就是旁路）来绕过 OS 的缓存，以避免页面的冗余副本和必须管理不同的退出策略

这样是为了保证缓冲池可控，而不会受操作系统干扰。

# 缓冲池替换策略
## LRU算法
最经典的算法，为缓冲池中的每个frame维护一个时间戳，需要进行替换的时候就找到最早的时间戳的frame，然后进行替换。

## CLOCK算法
LRU算法的简化版，不用维护时间戳，而是为每个frame维护一个标志位。用一个指针循环遍历整个缓冲池。如果某个frame在指针遍历之前用过了，就把标志位置为1。指针遍历到某个frame时，检查标志位，如果为1就置为0，不驱逐该page。如果为0就驱逐。

这样就相当于驱逐出最近K个时间单位内未用过的page（K为缓冲池大小）。

## LRU-K算法
它将最后K个引用的历史记录作为时间戳进行跟踪，并计算后续访问之间的间隔。这个历史记录被用来预测页面下一次被访问的时间。

## 查询本地化
记录每个事务用到的page，这样就可以在每个事务/ 查询的基础上选择要退出的页面。

# Dirty Page（脏页）
- Fast：将所有非脏页直接删除
- Slow：将所有脏页写回
- 后台写：定期遍历页表并将脏页写入磁盘


