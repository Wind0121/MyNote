# Timestamp Ordering Concurrency Control
- 时间戳排序(T /O)是一类乐观的并发控制协议，其中 DBMS 假定事务冲突很少。
- DBMS 不要求事务在被允许读/写数据库对象之前获得锁，而是使用时间戳来确定事务的可序列化顺序。
- 每个事务 Ti 被分配一个唯一的固定时间戳 TS(Ti)，该时间戳是单调递增的
- 如果 TS(Ti) < TS(Tj)，那么 DBMS 确保执行调度与 Ti 出现在 Tj 之前的串行调度等价

# Basic Timestamp Ordering (BASIC T/O)
- Basic T/O允许在不使用锁的情况下对数据库对象进行读写。
- 每个数据库对象 X 都被标记为**成功**对该对象执行读(表示为 R-TS(X))或写(表示为 W-TS(X))的**最后事务的时间戳**
- 如果一个事务试图以一种违反时间戳顺序的方式访问一个对象：即操作来自未来的数据，那么这个事务将会中止

## 读操作
- 如果 TS(Ti) < W-TS(X)，这就是读取“未来”写入的内容，违反了 Ti 相对于 X 的前写入者的时间戳顺序。
- 否则，读取是有效的，允许 Ti 读取 X。然后 DBMS 将 R-TS(X)更新为 R-TS(X)和 TS(Ti)的最大值。
- 读取成功后，它还必须在私有工作区中创建 X 的本地副本，以确保 Ti 的可重复读取（确保是该事务当时读取的版本）
![[Pasted image 20231214190821.png]]

## 写操作
- 对于写操作，如果 TS(Ti) < R-TS(X)或 TS(Ti) < W-TS(X)，则 Ti 必须重新启动（不希望覆盖“未来”更改）
- 否则，DBMS 允许 Ti 写入 X 并更新 W-TS(X)。
- 同样，它需要生成 X 的本地副本，以确保 Ti 的可重复读取
![[Pasted image 20231214191232.png]]

## 优化：托马斯写规则
- 对写操作的优化是，如果 TS(Ti) < W-TS(X)， DBMS 可以忽略写操作并允许事务继续，而不是中止并重新启动它
- 这违反了 Ti 的时间戳顺序，但这没有关系，因为**没有其他事务将读取 Ti 对对象 X 的写入**（因为未来有一个事务会重新写对象X）
![[Pasted image 20231214192233.png]]

## 特点
Basic T/O如果不适用托马斯写规则有以下特点：
- 它会生成一个可冲突序列化的调度
- 它不能有死锁，因为没有事务在等待
- 如果短事务持续产生冲突，则存在长事务“饥饿”的可能性（长事务时间戳早，短事务时间戳晚，如果长事务对短事务发生冲突，长事务就会中止）
- 如果事务只在它读取的所有事务的更改提交之后提交，那么调度是可恢复的。 否则，DBMS 不能保证事务读取将在从崩溃中恢复后恢复的数据
