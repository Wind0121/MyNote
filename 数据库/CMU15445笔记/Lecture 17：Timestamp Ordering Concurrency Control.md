# Timestamp Ordering Concurrency Control
- 时间戳排序(T /O)是一类乐观的并发控制协议，其中 DBMS 假定事务冲突很少。
- DBMS 不要求事务在被允许读/写数据库对象之前获得锁，而是使用时间戳来确定事务的可序列化顺序。
- 每个事务 Ti 被分配一个唯一的固定时间戳 TS(Ti)，该时间戳是单调递增的
- 如果 TS(Ti) < TS(Tj)，那么 DBMS 确保执行调度与 Ti 出现在 Tj 之前的串行调度等价

# Basic Timestamp Ordering (BASIC T/O)
- Basic T/O允许在不使用锁的情况下对数据库对象进行读写。
- 每个数据库对象 X 都被标记为**成功**对该对象执行读(表示为 R-TS(X))或写(表示为 W-TS(X))的**最后事务的时间戳**
- 如果一个事务试图以一种违反时间戳顺序的方式访问一个对象：即操作来自未来的数据，那么这个事务将会中止

## 读操作
- 如果 TS(Ti) < W-TS(X)，这就是读取“未来”写入的内容，违反了 Ti 相对于 X 的前写入者的时间戳顺序。
- 否则，读取是有效的，允许 Ti 读取 X。然后 DBMS 将 R-TS(X)更新为 R-TS(X)和 TS(Ti)的最大值。
- 读取成功后，它还必须在私有工作区中创建 X 的本地副本，以确保 Ti 的可重复读取（确保是该事务当时读取的版本）
![[Pasted image 20231214190821.png]]

## 写操作
- 对于写操作，如果 TS(Ti) < R-TS(X)或 TS(Ti) < W-TS(X)，则 Ti 必须重新启动（不希望覆盖“未来”更改）
- 否则，DBMS 允许 Ti 写入 X 并更新 W-TS(X)。
- 同样，它需要生成 X 的本地副本，以确保 Ti 的可重复读取
![[Pasted image 20231214191232.png]]

## 优化：托马斯写规则
- 对写操作的优化是，如果 TS(Ti) < W-TS(X)， DBMS 可以忽略写操作并允许事务继续，而不是中止并重新启动它
- 这违反了 Ti 的时间戳顺序，但这没有关系，因为**没有其他事务将读取 Ti 对对象 X 的写入**（因为未来有一个事务会重新写对象X）
![[Pasted image 20231214192233.png]]

## 特点
Basic T/O如果不适用托马斯写规则有以下特点：
- 它会生成一个可冲突序列化的调度
- 它不能有死锁，因为没有事务在等待
- 如果短事务持续产生冲突，则存在长事务“饥饿”的可能性（长事务时间戳早，短事务时间戳晚，如果长事务对短事务发生冲突，长事务就会中止）
- 如果事务只在它读取的所有事务的更改提交之后提交，那么调度是可恢复的。 否则，DBMS 无法保证事务读取的数据会在崩溃恢复后被还原，**该条见下**：
![[Pasted image 20231214193411.png]]


>Andy is not aware of any DBMS that uses the basic T/O protocol described here. 
>	→ It provides the building blocks for OCC / MVCC（它为OCC、MVCC提供了基础）

潜在的问题：
- 复制数据到事务工作区和更新时间戳的高开销（要求在本地保留读取的数据）
- 长时间运行的事务可能会”饿死“
- 在高并发系统上受到时间戳分配瓶颈的影响

# Optimistic Concurrency Control (OCC)
如果假定 txns 之间很少发生冲突，而且大多数 txns 的寿命都很短，那么强制 txns 获取锁或更新时间戳就会增加不必要的开销。这就引出了另一种优化方法——OCC

OCC定义如下：
- 乐观并发控制(OCC)是另一种乐观并发控制协议，它也使用时间戳来验证事务。
- 在 OCC 中，DBMS 为每个事务创建一个私有工作区。事务的所有修改都应用到这个工作区中。
- 任何读取的对象被复制到工作区中，任何写入的对象也被复制到工作区中并在那里进行修改。其他事务不能读取另一个事务在其私有工作区中所做的更改
- 当事务提交时，DBMS 比较事务的工作空间写集，以查看它是否与其他事务冲突。如果没有冲突，写集就被安装到“全局”数据库中

OCC包含三个阶段：
1. Read Phase：在这里，DBMS 跟踪事务的读/写集，并将它们的写操作存储在一个私有工作区中
2. Validation Phase（验证阶段）：当事务提交时，DBMS 检查它是否与其他事务冲突。
3. Write Phase：如果验证成功，DBMS 将私有工作空间更改应用到数据库。否则，它中止并重新启动事务。

## Validation Phase（验证阶段）
- DBMS 在事务进入验证阶段时为其分配时间戳
- 为了确保只允许可序列化的调度，DBMS 检查 Ti 与其他事务的 RW 和 WW 冲突，并确保所有冲突都是单向的，具体方法如下：

**Approach 1：Backward validation (from younger transactions to older transactions)**
![[Pasted image 20231214194838.png]]

**Approach 2：Forward validation (from older transactions to younger transactions)**
![[Pasted image 20231214194958.png]]
DBMS 检查提交事务与所有其他正在运行的事务的时间戳顺序。 尚未进入验证阶段的事务被分配一个∞时间戳。

若 TS(Ti)< TS(Tj)，则必须满足以下三个条件之一：
1. 在 Tj 开始执行之前，Ti 完成了所有三个阶段(串行排序)
2. Ti 在 Tj 开始写阶段之前完成，并且 Ti 不写入 Tj 读取的任何对象
3. Ti 在 Tj 完成其 Read 阶段之前完成其 Read 阶段，并且 Ti 不会对 Tj 正在读取或写入的任何对象进行写入

## 潜在的问题
- 将本地数据复制到事务的私有工作区的高开销 
- 验证/写入阶段的瓶颈
- 与其他协议相比，终止可能更浪费，因为它们只发生在事务已经执行之后
- 遭受时间戳分配瓶颈

# 幻读
![[Pasted image 20231214201610.png]]
在这张图中我们展示了幻读的表现，其发生原因是我们上锁只能在已有记录上进行上锁，而无法在不存在的数据上上锁。

解决幻读：
- Approach 1: Re-Execute Scans
	- 在提交时再次运行查询，查看是否会产生不同的结果，以确定遗漏的更改
- Approach 2: Predicate Locking
	- 在查询开始运行之前，从逻辑上确定谓词的重叠情况
- Approach 3: Index Locking
	- 在索引中使用键来保护范围

## Approach 1: Re-Execute Scans
简单粗暴的方式，基本不会使用

## Approach 2: Predicate Locking
除 HyPer（精确锁定）外，从未在任何系统中实施过

## Approach 3: Index Locking
insert、delete都需要更新索引，我们通过在索引上加锁来保证在不存在的数据上上锁

# 隔离级别
串行化之所以有用，是因为它允许程序员忽略并发问题。但强制执行它可能会导致并发次数过少，限制性能。我们可能希望使用较弱级别的一致性来提高可扩展性。这就引出了隔离级别。

隔离级别控制一个事务暴露给其他并发事务操作的程度。它能提供更高的并发性，但代价是将 txns 暴露于未提交的更改中：
- 脏读
- 不可重复读
- 幻读

隔离级别如下（从强到弱）：
![[Pasted image 20231214204023.png]]

隔离级别的具体实现：
![[Pasted image 20231214204145.png]]






