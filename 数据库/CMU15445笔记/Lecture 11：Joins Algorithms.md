# Join
## 必要性
- 关系模型要求将不同类型的但又有关联的表分开
- 我们进行查找时，常需要将不同的表进行连接查询

## 输出方式
- 数据：连接时直接将元组的所有数据一同连接，这被称为*早期物化*
- 记录id：连接时只保留元组的id，等到最后连接完毕才根据id查找对应元组，这被称为*晚物化*

## 开销分析
在这堂课中，我们做以下假设：
![[Pasted image 20231204154425.png]]
我们只考虑磁盘的I/O次数，以此作为我们的开销估计

# Nested Loop Join
## Simple Nested Loop Join
- 对外表的每一个元组，去遍历内表所有元组进行匹配。
- 这样的开销就是$M + (m*N)$
![[Pasted image 20231204154553.png]]

## Block Nested Loop Join
- 利用缓冲池，以page为单位进行遍历
- 这样的开销就是$M + (M * N)$，显然降低了
![[Pasted image 20231204154920.png]]

- 假设缓冲池有B个page的容量，那么每次可以从外表读取B-2个page，从内表读取一个page，留一个page作为连接输出
- 这样的开销就是$M + (\lceil \frac {M}{B - 2} \rceil * N)$ 
- 假设$(B-2)>M$，那么开销就是$M + N$
![[Pasted image 20231204155158.png]]

## Index Nested Loop Join
- 外表是不带索引的，内表是带索引的，我们就可以利用索引在常数级的时间找到匹配元组
- 这样的开销就是$M + (m * C)$
![[Pasted image 20231204155620.png]]

# Sort-Merge Join
分为两个阶段：
1. 排序：将两个表分别在join key上进行排序
2. 合并：调用两个游标遍历两个表，从而进行合并连接
![[Pasted image 20231204160528.png]]

开销分析：
![[Pasted image 20231204160554.png]]

# Hash Join
- 哈希连接算法的高层思想是使用哈希表将元组根据它们的连接属性分割成更小的块。
- 这减少了 DBMS 在计算连接时需要对每个元组执行的比较次数。
## Basic Hash Join
分为两个阶段：
1. Build：扫描外表并在join key上使用哈希函数 h1 填充哈希表
2. Probe：扫描内表，并在每个元组的join key上使用哈希函数 h1 跳转到哈希表中的相应位置， 并**尝试**找到匹配的元组，可能找不到
![[Pasted image 20231204161628.png]]

为了减少哈希冲突带来的误判，我们可以使用一种名为”Bloom Filter“的数据结构，它可以回答这样的问题：
- key 在哈希表中吗？要么绝对没有，要么可能有


