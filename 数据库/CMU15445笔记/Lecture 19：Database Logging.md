# Crash Recovery
恢复算法是一种确保数据库一致性、事务原子性和持久性的技术，尽管发生了故障。当发生崩溃时，内存中所有尚未提交到磁盘的数据都有丢失的风险。恢复算法的作用是防止崩溃后的信息丢失。

恢复算法包含两个部分：
- 在正常事务处理过程中采取行动，确保 DBMS 能够从故障中恢复
- 在发生故障后采取的行动，将数据库恢复到可确保原子性、一致性和持久性的状态

# Storage Types
![[Pasted image 20231216182902.png]]
- 易失性存储
- 非易失性存储
- 稳定存储器：理想存储器，实际上不存在（持久存储，且永远不会故障）

# Failure Classification
由于 DBMS 根据底层存储设备划分为不同的组件，因此 DBMS 需要处理许多不同类型的故障。其中一些故 障是可恢复的，而另一些则不能

## Type #1: Transaction Failures
事务失败发生在事务出现错误并且必须中止的时候。有两种可能发生的事务错误：
- 逻辑错误：由于某些内部错误条件(例如，完整性，约束违反)，事务无法完成。
- 内部状态错误：DBMS 必须终止一个活动的事务由于一个错误条件(例如，死锁)

## Type #2: System Failures
系统故障是承载 DBMS 的底层软件或硬件中的意外故障。这些故障必须在崩溃恢复协议中加以考虑。
- 软件故障：DBMS 实现出现问题(例如，未被捕获的除零异常)，系统不得不停止
- 硬件故障：托管 DBMS 的计算机崩溃(例如，电源插头被拔出)。我们假设非易失性存储内容不会因系统崩溃而损坏。

## Type #3: Storage Media Failure
存储介质故障是当物理存储设备损坏时发生的不可修复的故障。DBMS 无法从存储故障中恢复，需要人工干预。（数据库开发不考虑）

# Buffer Pool Management Policies
DBMS 需要确保以下保证：
- 一旦 DBMS 告诉某人它已提交 ，任何事务的更改都是持久的
- 如果事务终止 ，任何局部更改都是不持久的 

## steal policy
窃取策略决定 DBMS 是否允许未提交的事务覆盖非易失性存储中对象的最新已提交值：
- STEAL：允许
- NO-STEAL：不允许

## force policy
强制策略决定 DBMS 是否要求在允许提交事务之前将事务的所有更新都反映在非易失性存储上
- FORCE：要求
- NO-FORCE：不要求

## 小结
最容易实现的缓冲池管理策略称为 NO-STEAL + FORCE。

优点：
在这种策略下，DBMS 永远不必撤销已中止事务的更改，因为这些更改没有写入磁盘。DBMS 也无需重做已提交事务的更改，因为所有更改都会在提交时写入磁盘。

缺点：
NO-STEAL + FORCE 的一个限制是，事务需要修改的所有数据（即写集）都必须适合内存。否则，事务将无法执行，因为 DBMS 不允许在事务提交前将脏页面写入磁盘。

![[Pasted image 20231216185026.png]]

# Shadow Paging
影子分页是对以上方案的改进，DBMS 在写时复制页面以维护数据库的两个独立版本：
- master：只包含已提交事务的数据库
- shadow：由未提交事务的改变组成的临时数据库

更新只在shadow中进行。当事务提交时，shadow会原子切换，成为新的master。旧的master最终会被垃圾回收。
![[Pasted image 20231216185810.png]]

## 实现
- DBMS 以树结构组织数据库页面，其中根是单个磁盘页面。树有两个副本， master和shadow。根总是指向当前的master。当事务执行时，它只对shadow进行更改。
- 当事务想要提交时，DBMS 必须安装其更新。要做到这一点，它只需要覆盖根目录使其指向数据库的影子副本，从而交换主目录和影子目录。
	- 在覆盖根目录之前，所有的事务更新都不属于常驻磁盘的数据库。 
	- 覆盖根后，所有事务更新都是磁盘驻留数据库的一部分。这种对根的覆盖可以原子性地完成。

## recovery
- Undo：Remove the shadow pages. Leave the master and DB root pointer alone.
- Redo：Not needed at all

## 缺点
- 影子分页的一个缺点是复制整个页表的开销很大。
- 影子分页的提交开销也很高。提交需要页表，以及根，每一个更新的页面都要被刷新

# Write-Ahead Logging
- 维护一个独立于数据文件的日志文件，其中包含 txns 对数据库所做的更改
	- 假设日志存储在稳定的存储器中
	- 日志包含足够的信息来执行必要的撤销和重做操作，以恢复数据库
- DBMS 必须将与数据库对象所做更改相对应的日志文件记录写入磁盘，然后才能将该对象刷新到磁盘上
- Buffer Pool Policy：STEAL + NO-FORCE

## Implementation
- DBMS 首先将所有事务的日志记录存储在易失性存储器中。
- 在允许在非易失存储中覆盖该页之前，与已更新页相关的所有日志记录都被写入非易失存储。
- 直到事务的所有日志记录都被写入稳定存储，事务才被认为已提交。

- 当事务开始时，为每个事务写入一个< BEGIN > 记录到日志中 ，以标记其起始点。
- 当事务完成时，将< COMMIT >记录写入日志，并确保在它向应用程序返回确认之前，所有日志记录都被刷新。

- 每个日志条目都包含一下信息：
	- Transaction ID
	- Object ID
	- Before Value (used for UNDO)
	- After Value (used for REDO)

DBMS 必须将事务的所有日志条目刷新到磁盘，然后才能告诉外界事务已成功提交。对于这一步，系统可以使用“组 提交”优化来批量处理多个日志刷新，以分摊开销。刷新要么发生在日志缓冲区满的时候，要么发生在连续刷新之间经过了足够的时间的时候。

# Logging Schemes
日志记录的内容可能因实现而异

## Physical Logging
- 记录对数据库中特定位置所做的字节级更改 
- 例如：git diff

## Logical Logging
- 记录事务执行的高级操作
- 不一定局限于一个页面
- 与物理日志记录相比，每个日志记录需要更少的数据写入，因为每个记录可以在多个页面上更新多个元组
- 例如：The UPDATE, DELETE, and INSERT queries invoked by a transaction

## Physiological Logging
混合方法，日志记录以单个页面为目标，但不指定页面的数据组织。也就是说，根据页面中的槽号来识别tuple，而不指定更改在页面中的具体位置。因此，DBMS 可以在日志记录写入磁盘后重新组织页面

# Checkpoints
基于 WAL 的 DBMS 的主要问题是日志文件将永远增长。在崩溃之后，DBMS 必须Redo整个日志，如果日志文件很大，这可能需要很长时间。因此，DBMS 可以定期采取检查点，将所有缓冲区刷新到磁盘。

DBMS 应该多久执行一次检查点取决于应用程序的性能和停机时间需求。

## Blocking Checkpoint Implementation：
- DBMS 停止接受新事务，等待所有活动事务完成
- 将当前驻留在主内存中的所有日志记录和脏数据块清空到稳定存储器中
- 向日志中写入 < CHECKPOINT > 条目，并刷新到稳定存储器中

