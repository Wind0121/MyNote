>We are now going to talk about how to support the DBMS's execution engine to read/write data from pages
>下面我们将讨论如何支持 DBMS 的执行引擎从页面读/写数据

# 数据结构
DBMS中有许多地方使用了数据结构：
- Internal Meta-Data：用于维护DBMS系统信息
- Core Data Storage：用于存储核心数据，如tuple等
- Temporary Data Structures：临时数据结构，用于辅助运算操作等。如Hash Table for Join
- Table Indices：辅助DBMS更快找到对应的tuple，这将是接下来两节课的重点

# 哈希表
散列表实现了将键映射到值的无序关联数组。
![[Pasted image 20231113203521.png]]
其空间复杂度为O（n），时间复杂度平均为O（1），但最坏情况为O（n），如全碰撞的情况。

哈希表的实现包含两个重要部分：
- 哈希函数：用于将一个大的键空间映射到一个较小的域。我们需要考虑快速执行和碰撞率之间的权衡。
- 哈希方案：用于处理哈希冲突。我们需要考虑新建一个大哈希表和在插入过程中的额外操作之间作权衡。

# 哈希函数
哈希函数接受任意键作为输入。然后它返回该键的整数表示(即“哈希”)。该函数的输出是确定性的(即相同的键应该总是产生相同的哈希输出)。

我们不需要使用加密哈希函数，如SHA256等。加密哈希算法通常有更高的时间复杂度，且DBMS没有加密索引的需求。

以下是一些业界的哈希函数：
![[Pasted image 20231113203933.png]]

# 静态哈希方案
静态哈希方案是指哈希表的大小是固定的。这意味着，如果 DBMS 耗尽了哈希表中的存储空间，那么它必须从头开始重建一个更大的哈希表，这是非常昂贵的

## Linear Probe Hashing
如果发生哈希冲突，选取下一个空闲的位置作为该key对应的index。这样我们就需要在index中存储key，用于确定是否找到了该key对应的index。
![[Pasted image 20231113205318.png]]

如果需要删除key/value，有两种方法：
- 墓碑法：将原本key对应的index设置为墓碑，这样就可以知道该key已经不存在，且不妨碍其他key的查找
- 移动法：这个方法很难，需要移动其他key的index

## Robin Hood Hashing
这是线性探测哈希的扩展，旨在减少每个键在哈希表中的最佳位置(即它们被哈希到的原始槽)的最大距离。
-
- 每个条目还记录了它们与最优位置的“距离”。
- 在每次插入时，如果被插入的键离它最佳位置的距离比当前表项的距离更远，我们就替换当前表项，并继续尝试将旧表项插入表中更远的位置。


