>We are now going to talk about how to support the DBMS's execution engine to read/write data from pages
>下面我们将讨论如何支持 DBMS 的执行引擎从页面读/写数据

# 数据结构
DBMS中有许多地方使用了数据结构：
- Internal Meta-Data：用于维护DBMS系统信息
- Core Data Storage：用于存储核心数据，如tuple等
- Temporary Data Structures：临时数据结构，用于辅助运算操作等。如Hash Table for Join
- Table Indices：辅助DBMS更快找到对应的tuple，这将是接下来两节课的重点

# 哈希表
散列表实现了将键映射到值的无序关联数组。
![[Pasted image 20231113203521.png]]
其空间复杂度为O（n），时间复杂度平均为O（1），但最坏情况为O（n），如全碰撞的情况。

哈希表的实现包含两个重要部分：
- 哈希函数：用于将一个大的键空间映射到一个较小的域。我们需要考虑快速执行和碰撞率之间的权衡。
- 哈希方案：用于处理哈希冲突。我们需要考虑新建一个大哈希表和在插入过程中的额外操作之间作权衡。

# 哈希函数
哈希函数接受任意键作为输入。然后它返回该键的整数表示(即“哈希”)。该函数的输出是确定性的(即相同的键应该总是产生相同的哈希输出)。

我们不需要使用加密哈希函数，如SHA256等。加密哈希算法通常有更高的时间复杂度，且DBMS没有加密索引的需求。

以下是一些业界的哈希函数：
![[Pasted image 20231113203933.png]]

# 静态哈希方案
静态哈希方案是指哈希表的大小是固定的。这意味着，如果 DBMS 耗尽了哈希表中的存储空间，那么它必须从头开始重建一个更大的哈希表，这是非常昂贵的

## Linear Probe Hashing
如果发生哈希冲突，选取下一个空闲的位置作为该key对应的index。这样我们就需要在index中存储key，用于确定是否找到了该key对应的index。
![[Pasted image 20231113205318.png]]

如果需要删除key/value，有两种方法：
- 墓碑法：将原本key对应的index设置为墓碑，这样就可以知道该key已经不存在，且不妨碍其他key的查找
- 移动法：这个方法很难，需要移动其他key的index

## Robin Hood Hashing
这是线性探测哈希的扩展，旨在减少每个键在哈希表中的最佳位置(即它们被哈希到的原始槽)的最大距离：
- 这种策略从“富”键中窃取槽，并将其提供给“穷”键。
- 每个条目还记录了它们与最优位置的“距离”。
- 在每次插入时，如果被插入的键离它最佳位置的距离比当前表项的距离更远，我们就替换当前表项，并继续尝试将旧表项插入表中更远的位置。

![[Pasted image 20231113205621.png]]
![[Pasted image 20231113205634.png]]
这两张图就展示了key插入的比较过程，实际上可以理解为让整个哈希表的查找时间趋于平衡，尽可能确保每个key的查找时间都能比较少。

## Cuckoo Hashing
这种方法不使用单个哈希表， 而是用不同的哈希函数维护多个哈希表 ：
- 当我们插入时，我们检查每个表并选择一个有空闲槽的表
- 如果没有表有空闲槽，我们选择(通常是随机的) 并驱逐旧的表项。
- 然后我们将旧的表项重新散列到另一个表中。
- 在极少数情况下，我们可能会进入一个循环。如果发生这种情况，我们可以用新的哈希函数种子(不太常见)重建所有的哈希表，或者使用更大的表(更常见)重建哈希表。

该方案保证了插入和删除的O（1）复杂度，但插入会比较昂贵

## 静态哈希方案总结
静态散列方案要求 DBMS 知道它想要存储的元素的数量。否则，如果需要增加/缩小大小，必须重新构建哈希表。

# 动态哈希方案
动态哈希方案能够根据需要调整哈希表的大小，而不需要重建整个表。这些方案以不同的方式执行这种 大小调整，既可以最大化读，也可以最大化写。

## Chained Hashing
最常见的动态哈希方案。DBMS 为哈希表中的每个槽维护一个桶的链表。散列到同一槽的键被简单地插入到该槽的链表中。

## Extendible Hashing
链式哈希的改进变体，可以拆分桶而不是让链永远增长。这种方法允许哈希表中的多个槽位置指向同一个桶链。

重新平衡哈希表背后的核心思想是在 split 时移动桶条目，并增加要检查的位数以查找哈希表中的条目。这意味着 DBMS 只需要在分割链的桶内移动数据，其他所有的桶都保持不变。

这就是Project1中需要完成的 ExtandibleHashTable

桶分裂过程如下：
![[Pasted image 20231113211202.png]]
![[Pasted image 20231113211107.png]]
当我们需要插入的桶已满时，进行以下操作：
- 如果GlobalDepth == LocalDepth，将Directory增长，并将新增的条目指向原本的桶
- 将桶进行分裂，增加比较的位数，将原本一个桶内的元素按比较位划分到两个桶
- 将原本指向分裂桶的Directory条目进行重定向
- 完成插入操作

## Linear Hashing
这种方案不是在桶溢出时立即拆分桶，而是维护一个拆分指针，跟踪下一个要拆分的桶。无论这个指针是否指向溢出的存储桶，DBMS 总是分裂：
- 当任何桶溢出时，添加一个新的槽项，在拆分指针指向的地方拆分桶，并创建一个新的哈希函数
- 如果哈希函数映射到已经被拆分指针指向过的槽位，则应用新的哈希函数
- 根据分裂指针分裂桶，最终会到达所有溢出的桶。（这是哈希冲突解决的依据）
- 当指针到达最后一个槽时，删除原来的哈希函数，完全使用新的哈希函数代替

**插入过程**
发生溢出时，先在当前位置加上溢出桶。
![[Pasted image 20231113212723.png]]

在拆分指针指向的位置拆分桶，并使用新的哈希函数重新分配该桶的元素。
![[Pasted image 20231113212800.png]]

查找时先用原来的哈希函数，发现映射到的桶在拆分指针以上，表示已经被拆分过了，就使用新的哈希函数重新映射，就能映射到正确位置。
![[Pasted image 20231113212844.png]]

**删除过程**
根据拆分指针位置，通过正确哈希函数，找到key对应的index，并删除对应value
![[Pasted image 20231113213533.png]]

桶为空后，可以将槽位删除，并把新哈希函数删除（因为用不上了）
![[Pasted image 20231113213639.png]]

# 总结
支持 O(1) 查询的快速数据结构，在整个 DBMS 内部都会使用

但是，哈希表通常不适合用于表索引。我们将在下节课学到B+ Tree