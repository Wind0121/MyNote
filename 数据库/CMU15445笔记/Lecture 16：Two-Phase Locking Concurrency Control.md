# 前言
在上一节课中，我们已经知道了事务的并发需要两个事务之间可串行化，进而我们引出了“冲突可串行化”和“观察可串行化”两个判断方式。

现在的问题在于，这些都是在我们已经直到整个事务所有操作的情况下做出的判断，我们需要一种方式能保证在不知道事务操作的情况下，保证事务的并发。

我们将利用“Lock”来解决这个问题

# Transaction Locks
DBMS 使用 锁动态地为可序列化的事务生成执行计划，而无需提前知道每个事务的读/写设置。当有多个读和写时，这些锁在并发访问期间保护数据库对象。DBMS 包含一个集中的锁管理器，它决定事务是否可以获取锁。
![[Pasted image 20231214145627.png]]

## Lock和Latch的区别
这个也是经典话题了，具体区别可见下图，简单来说Lock是事务级别的锁，Latch是具体数据结构或共享变量的锁。
![[Pasted image 20231214145738.png]]

## Basic Lock Type
- Shared Lock (S-LOCK)：其实就是读锁。允许多个事务同时读取同一个对象的共享锁
- Exclusive Lock (X-LOCK)：其实就是写锁。排他锁允许事务修改对象。一次只有一个事务可以持有排他锁

## 事务锁的使用过程
- 事务必须从锁管理器请求锁。锁管理器根据其他事务当前持有的锁授予或阻塞请求。
- 当事务不再需要锁来释放对象时，必须释放锁。
- 锁管理器用哪些事务持有哪些锁以及哪些事务正在等待获取锁的信息更新其内部锁表

# Two-Phase Locking
二阶段锁是一种并发控制协议，它使用锁来确定是否允许事务动态访问数据库中的对象。该协议不需要提前知道事务将执行的所有查询。

## 过程
- 阶段一（增长）：在增长阶段，每个事务向 DBMS 的锁管理器请求它所需的锁。锁管理器授予/拒绝这些锁 请求
- 阶段二（收缩）：事务在释放第一个锁后立即进入收缩阶段。在收缩阶段，事务只允许释放锁。不允许他们获 取新的锁

## 缺陷
1. 级联中止问题：当一个事务中止时，必须回滚另一个事务，这导致了工作的浪费。
![[Pasted image 20231214150730.png]]
2. 脏读：也是上面这个问题，T2在T1的基础上读取数据，但T1之后回滚了，这就导致了T2出现了脏读。
3. 死锁：我们将使用检测和预防两种手段
4. 一些可能是可串行化的调度不适用于二阶段锁，换言之，二阶段锁减少了可使用的调度的范围，即降低了效率。

## 关于脏读的解决——Strong Strict Two-Phase Locking
如果一个事务写入的任何值永远不会被另一个事务读取或覆盖，直到第一个事务提交，则调度是严格的。
![[Pasted image 20231214151312.png]]

优点：
- DBMS 不会导致级联中止
- DBMS 还可以通过恢复修改元组的原始值来回滚abort事务的更改（因为中间不可能有别的事务进来，所以可以直接回复元组的初始值）
## 小结
![[Pasted image 20231214151619.png]]
可以看到强严格二阶段锁的范围比冲突可串行化的范围更小

# Deadlock Handling
二阶段锁本身无法解决死锁的问题，我们需要外部的手段来解决死锁，分为两种方式：
1. 死锁检测
2. 死锁预防

## Approach #1: Deadlock Detection
- 为了检测死锁，DBMS 创建一个等待图，其中事务是节点，如果事务 Ti 正在等待事务 Tj 释放锁，则存在 从 Ti 到 Tj 的有向边。
- 系统将定期检查等待图中的环(通常带有后台线程)，然后做出如何打破它的决定。

当DBMS检测到等待图的环时，就要选择一个“受害者”事务进行回滚，从而打破等待图中的环。“受害者”sh

