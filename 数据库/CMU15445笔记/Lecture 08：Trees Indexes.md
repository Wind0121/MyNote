# 表索引
表索引是表属性子集的副本，这些属性经过整理和排序，以便使用这些属性进行高效访问。说白了表索引就是原表的一个小表，用于快速查找对应的key-value。

为确保表索引的正确性，DBMS 确保表和索引的内容在逻辑上始终保持同步。

在每个数据库创建索引的数量之间存在权衡。虽然更多的索引使查找查询更快，但索引也使用存储并且需要维护。

# B+树
## 概述
B+Tree 是一种自平衡树数据结构，它保持数据排序，并允许在$O(logn)$内进行搜索、顺序访问、插入和删除。

B+树是一个 M-way 搜索树(其中 M 表示一个节点可以拥有的子节点的最大数量)：
- 它是完美平衡的 (即每个叶节点都在相同的深度)
- 只有叶子节点存储数据，内部节点只存储索引
- 除根节点外的每个内部节点至少为半满(M/2−1 <= \#keys <= M−1)
- 每个有 k 个键的内部节点有 k+ 1 个非空子节点
- 每个节点上的键按顺序排序

## 插入
要在 B+树中插入一个新条目，必须遍历树并使用内部节点来找出将键插入到哪个叶节点中：
1. 找到正确的叶子 L
2. 按排序顺序向 L 中添加新条目：
	- 如果 L 有足够的空间，则操作完成
	- 否则将 L 拆分为两个节点 L 和 L2。均匀地重新分配条目并向上复制中键。将指向 L2 的索引项插入到 L 的父节点中
3. 要拆分内部 节点 ，要均匀地重新分配条目，但要向上推中间键

## 删除
要在 B+树中删除一个条目，必须遍历树并使用内部节点来找出要删除的键在哪个叶节点中：
1. 找到正确的叶子 L 
2. 删除条目：
	- 如果 L 至少为半满， 则操作结束
	- 如果 L 只有M / 2 - 1个条目，尝试重新分配，借用兄弟姐妹
	- （这地方应该特指删除，与节点条件：M/2 - 1 <= \#key <= M - 1不冲突）
	- 如果再分配失败，合并 L 和 sibling
3. 如果发生合并 ，必须删除 parent 中指向 L 的条目

## 选择条件
因为 B+树是有序的，查找有快速的遍历，也不需要整个键。如果查询提供了搜索键的任何属性，DBMS 可以使用 B+Tree 索引。这与哈希索引不同，哈希索引需要搜索键中的所有属性。
![[Pasted image 20231118110942.png]]

## 重复键
在 B+Tree 中有两种解决重复键的方法：
- 附加记录 id 作为键的一部分。由于每个元组的记录 ID 是唯一的，这将确保所有的键都是可识别的
![[Pasted image 20231118112131.png]]
- 允许叶子节点溢出到包含重复键的溢出节点中。虽然不存储冗余信息，但这种方法维护和修改起来比较复杂
![[Pasted image 20231118112146.png]]

## 聚集索引
表按照主键指定的排序顺序存储，这样就便于范围查找：
![[Pasted image 20231118112440.png]]


# B+树设计选择
## 节点大小
根据存储介质的不同，我们可能喜欢更大或更小的节点大小：
- 例如，存储在硬盘上的节点通常以兆字节为数量级，以减少查找数据所需的寻道次数，并将昂贵的磁盘读取摊销到一大块数据上
- 而内存数据库 可能会使用小至 512 字节的页面大小，以便将整个页面放入 CPU 缓存中，同时减少数据碎片

## 合并阈值
虽然 B+树有一个关于在删除后合并下溢节点的规则，但有时暂时违反该规则以减少删除操作的数量可能是有益的。
- 例如，急切合并可能导致震荡，其中大量连续的删除和插入操作导致不断的拆分和合并。
- 它还允许批处理合并，其中多个合并操作同时发生，减少了必须在树上采取昂贵的写锁存器的时间。

## 可变长度键（不是很重要）
![[Pasted image 20231118113202.png]]

## 节点内搜索
![[Pasted image 20231118113651.png]]

# 优化
# 前缀压缩
大多数情况下，当我们在同一个节点上有键时，每个键的某些前缀会有部分重叠(因为在排序的 B+树中， 相似的键最终会紧挨着彼此）。们可以简单地在节点的 开头存储一次前缀，然后只包括每个槽中每个键的唯一部分。
![[Pasted image 20231118115042.png]]

## 重复数据删除
在索引允许非唯一键的情况下，我们最终可能会得到叶节点一遍又一遍地包含相同的键，只是附加了不 同的值。一种优化方法是只写一次键，然后用它的所有相关值跟随它。
![[Pasted image 20231118115023.png]]

## 后缀截断
在大多数情况下，内部节点中的键项只是用作路标，而不是用于它们实际的键值(因为即使索引中存在键，我 们仍然需要搜索到底部以确保它没有被删除)

我们可以利用这一点，内部节点只需存储将探测正确路由到正确节点所需的最小前缀。

## 指针切换
![[Pasted image 20231118115435.png]]
说白了就是如果page已经在缓冲池中了，就将找到的page id转化成指向page的指针，这样就可以省去从page table中查找的步骤。

