# 索引并发控制
到目前为止，我们假设我们讨论的数据结构是单线程的。然而，大多数 DBMS 需要允许多个线程安全地访问数据结构，以利用额外的 CPU 内核并隐藏磁盘 I/O 停顿。

并发控制协议的正确性包含两个方面：
- 逻辑正确性：这意味着线程能够读它应该读的值，例如线程应该读回它之前写的值。
- 物理正确性：这意味着对象的内部表示是可靠的，例 如在数据结构中没有指针会导致线程读取无效的内存位置。

# Lock vs Latches
- Lock：高级逻辑原语，用于事务级别的控制
- Latches：低级保护原语，用于内存中的数据结构保护，包含两种模式：
	- READ：允许多个线程同时读取同一项
	- WRITE：只允许一个线程访问该项目
![[Pasted image 20231120154542.png]]

# Latch Implementations
## Approach #1: Blocking OS Mutex
![[Pasted image 20231120155354.png]]
这种实现就是OS内置的互斥锁基础设施，它包含用户空间中的自旋锁和操作系统级的互斥锁。首先尝试获取用户空间中的自旋锁，如果能获取就设置为上锁。否则就尝试获取操作系统中的互斥锁，如果不能获取就进入sleep。

总的来说，这不是个好主意，因为它是操作系统管理的。

## Approach \#2: Test-and-Set Spin Latch (TAS)
自旋锁存器本质上是线程试图更新的内存位置(例如，将布尔值设置为 true)。线程执行 CAS（原子比较与交换）以尝试更新内存位置。

DBMS 可以控制如果无法获得锁存会发生什么。它可以选择再次尝试(例如，使用 while 循环)或允许 OS 重新调度它。

![[Pasted image 20231120160101.png]]

## Approach #3: Reader-Writer Latches
以上两种锁都不支持不同模式地设置锁。DBMS 需要一种允许并发读取的方法，所以如果应用程序有大量的读取，它将有更好的性能，因为读取器可以共享资源而不是等待。

读写器锁存器允许锁存器保持在读或写模式。它跟踪在每种模式下持有锁存器并等待获得锁存器的线程数。读写器锁存器使用前面两个锁存器实现中的一个作为基元，并有额外的逻辑来处理读写器队列。
![[Pasted image 20231120160630.png]]

# 哈希表锁存
哈希表上锁方式有两种：
- 页面锁存：每个页面都有自己的读写锁存，保护其整个内容。线程在访问页之前获得读锁存或写锁存。
- 槽位锁存：每个槽位都有自己的闩锁。这增加了并行性，因为两个线程可以访问同一页面上的不同插槽。 但它增加了访问表的存储和计算开销，因为线程必须为它们访问的每个插槽获取一个闩锁。

还可以实现无锁方式：
使用CAS指令创建一个无锁存器的线性探测哈希表。通过尝试将一个特殊 的“null”值与我们希望插入的元组进行比较和交换，可以实现在一个插槽上插入。如果这失败了，我们 可以探测下一个槽，一直到它成功为止。

# B+树锁存
B+树不做锁存情况下，并发出现的问题：
![[Pasted image 20231120163445.png]]
![[Pasted image 20231120163458.png]]

## Latch crabbing/coupling
![[Pasted image 20231120163847.png]]
这是一个B+树并发控制地协议，基本思想就是一次获取两个锁，如果下一个锁安全就释放上一个锁。

安全的定义：
- 插入模式下，该结点不能为满
- 删除模式下，该结点必须半满

具体操作：
- Search：从根部开始向下，反复获取child的latch，然后释放parent的latch
- Insert/Delete：从根部开始往下，根据需要获得 X 个Latch。一旦子节点 is Latched，检查它是否安全。如果子节点是安全的，则释放其所有祖节点上的Latch。

**例子：可以查看ppt上的图片例子**

## Improved Latch Crabbing Protoco
- Basic Latch crabbing算法的问题在于，每次插入/删除操作时，事务都会在根节点上获得一个独占锁存器。这限制了并行性。
- 相反，我们可以假设，需要调整节点大小（即拆分/合并节点）的情况很少发生，因此事务可以获取共享锁存器（读锁），直至叶节点。
- 每个事务都会假设通往目标叶节点的路径是安全的，并使用 "读 "锁存器和 "捕捉 "来到达目标叶节点并进行验证。
- 如果叶子节点不安全，我们就会中止，然后执行之前的算法，获取写入锁存器。

具体步骤如下：
- Search：和之前的算法一样
- Insert/Delete：设置 "读 "锁存器，如同Search，转到叶子，并在叶子上设置 "写 "锁存器。如果叶子不安全，则释放所有先前的锁存器，并使用先前的算法重新启动事务。

## 叶子节点扫描
在上述的例子中，我们都是自上而下的获取锁，但事实上我们可能进行范围查询，这就涉及叶子节点扫描。

然而，叶节点扫描很容易发生死锁，因为现在我们有线程试图同时在两个不同的方向上获取独占锁(例如， 线程 1 试图删除，线程 2 进行叶节点扫描)。**索引锁存器不支持死锁检测或避免。**

因此，程序员处理这个问题的唯一方法就是通过编码规范 ：
- 规定叶子节点遍历方向，比如只能从小到大的遍历。
- 支持失败情况的应对，如果一个线程试图获得叶节点上的闩锁，但该闩锁不可用，那么它应该迅速中止其操作(释放它持有的任 何闩锁)并重新启动操作。

