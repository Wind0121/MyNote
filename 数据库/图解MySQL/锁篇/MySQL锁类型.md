# 全局锁
## 如何使用
要使用全局锁，则要执行这条命令：
```
flush tables with read lock
```
执行后，**整个数据库就处于只读状态了**，这时其他线程执行以下操作，都会被阻塞：
- 对数据的增删改操作，比如 insert、delete、update等语句；
- 对表结构的更改操作，比如 alter table、drop table 等语句。

如果要释放全局锁，则要执行这条命令：
```
unlock tables
```
当然，当会话断开了，全局锁会被自动释放。

## 使用场景
进行全库逻辑备份

## 缺点
锁定整个数据库，将导致业务的停滞

# 表级锁
## 表锁
锁定某个表

## 元数据锁
元数据锁是自动上的，我们使用一张表的时候都需要用到这个表的元数据，也就会上元数据锁。

## 意向锁
包括IX、IS、SIX

# 行级锁
## Record Lock
Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：
![[Pasted image 20231224120754.png]]
## Gap Lock
Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。

间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，**间隙锁之间是兼容的**，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。
![[Pasted image 20231224120801.png]]

## Next-Key Lock
Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
![[Pasted image 20231224120807.png]]

## 插入意向锁
一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。

如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

插入意向锁并非意向锁，实际上是一种等待状态的行锁。



