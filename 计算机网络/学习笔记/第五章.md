# 路由选择算法
路由：按照某种指标找到源节点到目标节点的较好路径。即路由器的序列。

子网内部的主机不需要路由，直接交换即可，因而主机-主机的路由=网络-网络的路由=路由器-路由器的路由。
![[Pasted image 20231006092103.png]]
汇集树即最优路径组成的树
![[Pasted image 20231006092958.png]]

![[Pasted image 20231006093258.png]]

## 链路状态（Link State）算法
link state算法实际上就是Dijkstra算法，首先各路由器需要知道整个网络的拓扑结构，然后就可以运行Dijkstra算法，从而得到汇集树。

工作过程：
![[Pasted image 20231006100456.png]]
第四步实际上就是泛洪的过程，需要将该路由器的相邻信息传递给其他所有路由器，最后相当于所有路由器都有了其他路由器的相邻信息，这就是我们需要的网络拓扑结构。

序号Seq用于标识该扩散分组的版本号，如果已经收到，就不用继续洪泛。年龄Age其实就是TTL，每经过一个路由器就减一。
![[Pasted image 20231006102116.png]]

Dijkstra算法较为简单，不再详述。

## 距离向量（Distance Vector）算法
实际上这就是一个Bellman-Ford算法
![[Pasted image 20231006105553.png]]
因为是异步的算法，所以所有路由器可以分别定时进行迭代计算，以下是一个例子：
![[Pasted image 20231006110803.png]]

**DV的无穷计算问题**
DV的特点：
- 好消息传的快
- 坏消息传的慢
![[Pasted image 20231006111923.png]]

坏消息传的慢的本质是每个路由器并没有得到真正的信息，都是盲人摸象。

在这个例子中，A到B变为不可达，但B却从C处得知是可达的，因而能继续更新。如此循环往复无限次，所有路由器才会把A的距离更新为INF。
![[Pasted image 20231006111935.png]]

**水平分裂算法->解决无穷计算**
我们以C为例子解释这个算法。C知道B是它去A的下一跳，因而无论如何他传给B的信息都是INF。但对于D，由于C是D的下一跳，C就把他认为的到A的距离传给D（真实距离）。如此一来就在C这个地方形成了分裂。

粗略想想感觉没什么问题，因为一个节点不可能通过他的前一跳节点得到下一跳节点的距离。

这样坏消息也实现了一次交换前进一个路由器的速度。
![[Pasted image 20231006112625.png]]


但这个算法同样还有问题，因而它只能在特定情况下解决无穷计算的问题，不过至少不会出错。
![[Pasted image 20231006113319.png]]

**LS和DV算法的比较**
![[Pasted image 20231009090158.png]]

# 因特网中自治系统内部的路由选择：OSPF
OSPF利用IP数据报进行传输，因而是一种传输层协议。
![[Pasted image 20231009092742.png]]

OSPF特性：
- 所有的OSPF报文都是经过认证的（防止恶意的攻击）
- 允许有多个代价相同的路径存在
- 支持按照不同的代价计算最优路径

![[Pasted image 20231009093916.png]]

