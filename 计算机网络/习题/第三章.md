![[Pasted image 20231120111959.png]]
校验和的计算就是求和+回卷+求反

使用反码的原因：接收方可以直接将整个报文段按16比特求和，若结果为全1，就能说明检验正确，这样实现起来比较简单。如果有某一位不为1，则说明检测出错误。

![[Pasted image 20231120112201.png]]
a、b的情况可能发生在ACK在网络中停留过长，而发送方重新发送了报文后才收到ACK，这样接收方就发送了已经不在当前窗口的ACK。

![[Pasted image 20231120112400.png]]
这道题是一个比较全面的题目：
h：【1，6】时间段发送了1+2+4+8+16+32=63个报文段，那么第70个报文段会在第7个传输轮回中发送。


![[Pasted image 20231122164026.png]]
![[Pasted image 20231122164034.png]]

![[Pasted image 20231122164051.png]]
![[Pasted image 20231122164058.png]]
以上这个rdt2.1接收方有一个严重问题就是没有考虑ACK/NAK错误时，如何处理发送方的重发。如果发送方重复发送，接收方同样需要发送ACK表示已经受到过。

![[Pasted image 20231122170403.png]]
对于a：
- 如果k之前的ACK全部被发送方收到，则发送方当前窗口范围是\[k, k+N-1]
- 如果k之前的ACK全部没被收到，则发送方当前窗口范围是\[k-N,k-1]
对于b：答案不是很明确，


![[Pasted image 20231123105710.png]]
![[Pasted image 20231123105719.png]]
GBN的ACK是已经接收到的最后数据报的序号
TCP的ACK是预期收到的数据报的序号，也就是已经收到的+1
