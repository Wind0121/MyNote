# 概述和传输层服务
服务：为运行在不同主机上的应用进程提供逻辑通信
- 发送方将应用层报文分成报文段，然后交给网络层
- 接收方将报文段进行重组，然后交给应用层

![[Pasted image 20230914172500.png]]

逻辑通信：
两个家庭通信的例子非常好的讲解了逻辑通信的含义，即运输层实际上只做了端到端交付后的进程到进程工作，但对于进程而言，这个运输层似乎就做完了所有运输服务，因而这就是一种逻辑通信。
![[Pasted image 20230914172530.png]]


IP的服务模型是尽力而为交付服务，这意味着IP尽它“最大的努力”在通信的主机之间交付报文段，但它并不做任何确保。特别是，它不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性。由于这些原因，IP被称为不可靠服务(unreliable service)。

因而运输层只能在IP服务模型的基础上打补丁，可以拓展一些功能，但有些功能则无法实现。像负责端到端的IP协议自己都无法保证传输时间，那么负责进程到进程的运输层协议当然无法保证传输时间。
![[Pasted image 20230914173211.png]]

# 多路复用/解复用
![[Pasted image 20230914190137.png]]
- 多路复用：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用
- 多路解复用（多路分解）：将运输层报文段中的数据交付到正确的套接字的工作称为多路分解

## TCP多路复用/解复用
发送消息时，应用层向传输层传递Socket和对应数据，传输层进行封装后，接着传到网络层，网络层会根据TCP头部信息封装IP头部，然后通过网卡传递。接收消息同理。
![[Pasted image 20230914184704.png]]
TCP套接字包含四元组标识，发送主机和接收主机都依靠这四元组进行定位。

## UDP多路复用/解复用
发送消息时，应用层向传输层传递Socket、数据、目标IP和端口号（这是UDP的区别）。
![[Pasted image 20230914185502.png]]
在接收端，UDP套接字用二元组标识 (数据报中的目标IP地址、目标端口号)

如果两个不同源IP地址/源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的套接字

# 无连接的服务（UDP）
![[Pasted image 20230914192025.png]]
发送方：
1. 从应用进程得到数据
2. 附加上为多路复用/多路分解所需的源和目的端口号及差错检测信息，形成报文段（数据报）
3. 递交给网络层，尽力而为的交付给接收主机

接收方：
1. 从网络层接收数据报
2. 根据目的端口号，将数据交付给相应的应用进程

## UDP报文格式
![[Pasted image 20230914193726.png]]
可知端口号都是16位的，因而就是从0~65535

## 检验和
从上述UDP报文格式可知，UDP需要计算校验和并进行传递。计算方式为，将数据（仅仅时报文）按16比特的字段进行相加，所得到的和进行反码运算，就是检验和。接收方按同样方式计算校验和，跟报文段中的检验和进行对比即可。

接收方也可以将数据和检验和全部相加，如果报文段没有改变则这个答案应该是一个全1的值（这个自己想想）。
![[Pasted image 20230914193854.png]]

检验码出错，则报文段肯定出错。检验码没出错，报文段也可能出错。此时就得重传。

事实上UDP也可以进行可靠传输，不过得在应用层中实现。

# 可靠数据传输原理
难点是如何在不可靠的信道传输基础上建立一个可靠的数据传输。
![[Pasted image 20230916201100.png]]

接下来我们只考虑单向的可靠数据传输问题（当然控制信息是双向传输的），实际上双向传输就是两个单项传输的综合，接下来我们将层层开发可靠的数据传输协议的发送方和接收方。
## 构造可靠数据传输协议
![[Pasted image 20230916202515.png]]
在Rdt1.0的情况下，我们的协议没有任何多余的功能，发送方只负责接受调用，然后封装分组并发送，一直都是一个状态。接收方也只负责接收分组，解封装后向上传递。


![[Pasted image 20230916202643.png]]
在这种情况下，发送方会计算校验和，接收方会根据校验和来检测数据是否出错，然后发送反馈。具体流程可见下：
![[Pasted image 20230917084323.png]]

rdt2.0有一个致命的错误就是没有考虑ACK、NAK控制报文的出错，因而我们引入序号机制，给每个分组都标上序号。如果ACK、NAK出错，发送方就只管重传，如果重复，接收方是可以根据需要进行判断然后丢弃的。很显然，这是一个**停等协议**
![[Pasted image 20230917090127.png]]
![[Pasted image 20230917090412.png]]
这里接收方发现重复后，是一样要发ACK的，表示已经收到过这个重复报文了，让发送方进入下一个状态。

rdt2.2：功能同rdt2.1，但只使用ACK(ack 要编号），使用对前一个数据单位的ACK，代替本数据单位的NAK。这是为之后流水线协议做准备

![[Pasted image 20230917093420.png]]
发送方进行超时检测，接收方不需要（因为只需要有一个超时就行了）
![[Pasted image 20230917094701.png]]
注意，这里收到错误的ACK后，不会做任何操作，而是等待超时，然后自动重发。

rdt3.0已经是一个完备的协议了，即能够实现正常功能，但由于是停等协议，效率过低。

## 流水线可靠数据传输协议
流水线：允许发送方在未得到确认的情况下，发送多个分组
- 增加序号范围：需要多个bit位来表示序号
- 发送方/接收方都需要有缓冲区：发送方可能需要重传、接收方可能乱序
- 两种常用的流水线协议是回退N步（GBN）、选择重传（SR）

**发送缓冲区**
定义：内存中的一个区域，落入缓冲区的分组可以发送
大小：一次最多可以发送多少个未经确认的分组
![[Pasted image 20230918091059.png]]

![[Pasted image 20230918090647.png]]

**发送窗口**
定义：在发送缓冲区中，已经发送但未经确认分组的序号构成的空间
后沿与前沿：后沿就是左边，前沿就是右边。一开始后沿=前沿
前沿移动：在不超过发送缓冲区的前提下，发送一个分组，前沿就前移
后沿移动：收到最老分组的确认，后沿前移，同时发送缓冲区跟着前移

GBN：拥有当前最老未确认分组的计时器，如果超时，就会回退到这个分组，重新发送N个分组
SR：拥有所有未确认分组的计时器，哪个超时就重新发哪个

**接收窗口=接收缓冲区**
定义：收到的分组序号落在接收窗口内才能接收，否则丢弃
大小：大小=1，则只能顺序接收；大小>1，则可以乱序接收

GBN：GBN是大小=1的接收窗口，因而只能接收当前希望接收的序号分组。如果收到了不是当前序号的分组，接收端就会丢弃，同时发送当前已经收到的最高序号分组的确认（这样发送端就知道没有收到当前分组）
SR：SR是大小>1的接收窗口，因而会对每个落入接收窗口的序号分组发确认，同时如果当前最老的序号分组已经接收，就会将接收窗口前移，从而容纳下一个分组。







