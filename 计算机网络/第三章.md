# 概述和传输层服务
服务：为运行在不同主机上的应用进程提供逻辑通信
- 发送方将应用层报文分成报文段，然后交给网络层
- 接收方将报文段进行重组，然后交给应用层

![[Pasted image 20230914172500.png]]

逻辑通信：
两个家庭通信的例子非常好的讲解了逻辑通信的含义，即运输层实际上只做了端到端交付后的进程到进程工作，但对于进程而言，这个运输层似乎就做完了所有运输服务，因而这就是一种逻辑通信。
![[Pasted image 20230914172530.png]]


IP的服务模型是尽力而为交付服务，这意味着IP尽它“最大的努力”在通信的主机之间交付报文段，但它并不做任何确保。特别是，它不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性。由于这些原因，IP被称为不可靠服务(unreliable service)。

因而运输层只能在IP服务模型的基础上打补丁，可以拓展一些功能，但有些功能则无法实现。像负责端到端的IP协议自己都无法保证传输时间，那么负责进程到进程的运输层协议当然无法保证传输时间。
![[Pasted image 20230914173211.png]]

# 多路复用/解复用
![[Pasted image 20230914190137.png]]
- 多路复用：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将报文段传递到网络层，所有这些工作称为多路复用
- 多路解复用（多路分解）：将运输层报文段中的数据交付到正确的套接字的工作称为多路分解

## TCP多路复用/解复用
发送消息时，应用层向传输层传递Socket和对应数据，传输层进行封装后，接着传到网络层，网络层会根据TCP头部信息封装IP头部，然后通过网卡传递。接收消息同理。
![[Pasted image 20230914184704.png]]
TCP套接字包含四元组标识，发送主机和接收主机都依靠这四元组进行定位。

## UDP多路复用/解复用
发送消息时，应用层向传输层传递Socket、数据、目标IP和端口号（这是UDP的区别）。
![[Pasted image 20230914185502.png]]
在接收端，UDP套接字用二元组标识 (数据报中的目标IP地址、目标端口号)

如果两个不同源IP地址/源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的套接字

# 无连接的服务（UDP）
![[Pasted image 20230914192025.png]]
发送方：
1. 从应用进程得到数据
2. 附加上为多路复用/多路分解所需的源和目的端口号及差错检测信息，形成报文段（数据报）
3. 递交给网络层，尽力而为的交付给接收主机

接收方：
1. 从网络层接收数据报
2. 根据目的端口号，将数据交付给相应的应用进程

## UDP报文格式
![[Pasted image 20230914193726.png]]
可知端口号都是16位的，因而就是从0~65535

## 检验和
从上述UDP报文格式可知，UDP需要计算校验和并进行传递。计算方式为，将数据（仅仅时报文）按16比特的字段进行相加，所得到的和进行反码运算，就是检验和。接收方按同样方式计算校验和，跟报文段中的检验和进行对比即可。

接收方也可以将数据和检验和全部相加，如果报文段没有改变则这个答案应该是一个全1的值（这个自己想想）。
![[Pasted image 20230914193854.png]]

检验码出错，则报文段肯定出错。检验码没出错，报文段也可能出错。此时就得重传。

事实上UDP也可以进行可靠传输，不过得在应用层中实现。

# 可靠数据传输原理
难点是如何在不可靠的信道传输基础上建立一个可靠的数据传输。
![[Pasted image 20230916201100.png]]

接下来我们只考虑单向的可靠数据传输问题（当然控制信息是双向传输的），实际上双向传输就是两个单项传输的综合，接下来我们将层层开发可靠的数据传输协议的发送方和接收方。
## 构造可靠数据传输协议
![[Pasted image 20230916202515.png]]
在Rdt1.0的情况下，我们的协议没有任何多余的功能，发送方只负责接受调用，然后封装分组并发送，一直都是一个状态。接收方也只负责接收分组，解封装后向上传递。

![[Pasted image 20230916202643.png]]


