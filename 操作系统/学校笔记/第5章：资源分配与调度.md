# 资源管理概述
## 资源管理的目的和任务

**必要性**
计算机中的资源是有限的，需要操作系统进行分配

**分配方式**
- 静态分配：在进程运⾏前，操作系统⼀开始就把他所要的全部资源都分配
- 动态分配：进程在运⾏的过程中，边运⾏边向操作系统提出申请，操作系统根据申请分配资源

## 虚拟资源
- 物理资源（实资源）
- 虚拟资源（逻辑资源）

# 资源管理的机制和策略
- 机制：进行资源分配所必须的基础设施和部件
- 策略：资源分配的原则

## 资源分配机制
**资源描述器（RD）**
- 描述各类资源的最小分配单位的数据结构
- 资源名,类型,大小,地址,分配标志,描述器连接信息,存取权限等

**资源信息块（RIB）**
- 用于对每类资源进行有效分配
- 资源分配程序包括分配程序和回收程序
![[Pasted image 20231125102029.png]]
## 资源分配策略
**先请求先服务**
- 队列结构：每⼀次新产⽣的请求在队尾
- 当资源可用的时候取队首元素，并满⾜其需要
- 先来的请在队列⾸部，后来的在队列末尾
![[Pasted image 20231125102429.png]]
**优先调度**
- 对每⼀个进程指定⼀个优先级
- 每⼀个新产⽣的请求，按其优先级的⾼低插到相应的位置，优先级越⾼，越靠近队首。优先级越低，越靠近队尾
- 当资源可⽤时，取队首元素，并满⾜其需要
![[Pasted image 20231125102455.png]]

**针对设备特性的调度策略（以磁盘为例）**
磁盘的⼯作原理：
- 先移动磁盘的移动臂找到合适的柱⾯
- 接着旋转这个柱⾯,找到要找的磁道和扇区
![[Pasted image 20231125102717.png]]

移臂调度：
- 最短寻道时间优先算法（SSTF）：总是选取与当前移动臂位置距离最短的那个I/O请求
- 扫描算法（SCAN）：总是选取与当前移动臂前进⽅向上最近的那个I/O请求

旋转调度：
- 总是选取与当前读写头最近的那个I/O请求
- 先执⾏移臂调度在执⾏旋转调度

# 死锁
## 死锁的定义
- 在两个或多个并发进程中，如果每个进程持有某种资源⽽⼜都等待着别的进程释放它或它们现在保持着的资源，否则就不能向前推进。此时，称这⼀组进程产⽣了死锁
- 进程在占有某个资源⽽请求某种资源，当该进程占有的资源是别⼈请求的资源时，就可能产⽣死锁

## 产生死锁的原因
这个死锁图解要会看，实际上就是两个并发进程对资源的竞争区域，我们的运行折线不能经过这些区域。
![[Pasted image 20231125112441.png]]

## 产生死锁的必要条件
![[Pasted image 20231125112617.png]]
## 系统状态分析
- 初始状态 
	- ⼀组确定的进程集合 
	- ⼀组不同类型的资源，以及各类可利⽤的资源数⽬ 
	- 资源分配矩阵: $a_{ij}$代表进程i占有j类资源数⽬ 
	- 资源请求矩阵: $d_{ij}$代表进程i还需要j类资源数⽬

![[Pasted image 20231125112847.png]]
- 安全状态
	- 当进程请求某类资源时，进程对该类资源的需求量⼩于当前时刻系统所拥有的该类资源的数⽬，那么满⾜进程的这次请求，系统是安全的
	- 要求进程声明需要资源的最⼤数⽬(进程最多最多就需要那么多资源),如果当前计算机剩余的资源⼤于进程声明所需要的总的资源，就称为安全的

## 资源分配图
- 两类顶点 
	- 所有的进程P 
	- 所有的资源R
- 两类有向边
	- 资源请求边：P->R
	- 资源分配边：R->P
![[Pasted image 20231125113532.png]]

## 解决死锁的策略
- 把四个必要条件的其中⼀个弄成不满⾜
- 采用资源静态分配法预防死锁
- 采用资源动态分配、有序分配方法来避免死锁
- 当死锁发生时检测死锁，并设法恢复
- 忽略死锁，一旦死锁就重启系统

## 死锁的预防
静态预防死锁：在作业调度的时候就给选中的作业分配它所需要的全部资源(⼀开始就分配所有资源给作业)

缺点如下：
- 进程难以提出所有需要的资源
- 提早获取资源，容易导致资源闲置

## 死锁的避免
**有序资源分配法**
系统中所有资源都给定⼀个唯⼀的编号，所有分配请求必须以上升的次序进⾏。当遵守上升次序的规则时，若资源可⽤，则予以分配

**银行家算法**
- 申请者事先说明对各类资源的最⼤需求量。在进程活动期间动态申请某类资源时，由系统审查现有该类资源的数⽬是否能满⾜当前进程的最⼤需求量，如能满⾜就予以分配，否则拒绝
- 当前剩余资源>该进程声明的最⼤需求量，就可以满⾜该进程的局部资源分配需求

## 死锁的检测和忽略
**死锁的检测**
发现死锁的原理是考查某一时刻系统状态是否合理，即是否存在一组可以实现的系统状态，能使所有进程都得到它们所申请的资源而运行结束

**死锁的忽略**
重启系统

