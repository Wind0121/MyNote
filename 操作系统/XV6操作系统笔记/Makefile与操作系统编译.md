- [[#概述|概述]]
- [[#操作系统内核的编译|操作系统内核的编译]]
- [[#如何链接|如何链接]]
- [[#操作系统内核编译文件|操作系统内核编译文件]]
- [[#用户应用程序编译|用户应用程序编译]]
- [[#XV6装载到qemu|XV6装载到qemu]]
- [[#总结|总结]]
# 概述
整个XV6分为操作系统内核与用户应用程序两部分，它们都在qemu，也就是一个C程序模拟的虚拟机上运行。

# 操作系统内核的编译
在XV6文件中，kernel目录下的文件都属于内核文件，Makefile将整个kernel目录下的文件编译成目标文件（\*.o），然后通过链接器将所有目标文件链接成可执行文件kernel，这就是操作系统内核。

# 如何链接
![[Pasted image 20231226172400.png]]
- 根据Makefile中的内容，生成kernel可执行程序的依赖项是所有内核文件都编译成目标文件、准备好kernel.ld文件、user目录下的initcode文件。然后会在命令行中指令高亮部分的指令。
- 首先进行链接，链接器通过链接脚本（.ld文件）将所有内核目标文件链接成可执行文件kernel。
- 然后进行反汇编，通过OBJDUMP指令生成一个kernel.asm，这就是可执行文件的汇编形式。
- 然后再次进行反汇编，生成了一个kernel可执行文件的所有段地址，也就是kernel.sym文件。

**请注意**：这里使用的编译器、汇编器、链接器都是riscv下的工具，这些都已经在Makefile中指明，通过XV6的编译启动输出也可以看出这一点。
![[Pasted image 20231226173002.png]]

# 操作系统内核编译文件
通过kernel.asm文件我们可以看到整个操作系统内核的汇编形式，也可以看到内核的入口地址为0x80000000。qemu（虚拟机）装载操作系统时就会将其装载到这个内存地址。
![[Pasted image 20231226173217.png]]

# 用户应用程序编译
用户应用程序会随着文件镜像一同编译，然后装入qemu（虚拟机）的物理存储，这样内核的文件系统就可以读取这些应用程序，并进行执行。

通过Makefile可以看出，fs.img依赖用户应用程序文件以及mkfs文件，之后会通过mkfs程序生成整个fs.img文件。
![[Pasted image 20231226173458.png]]

我们可以通过另一种形式验证这个知识点，我们删除Makefile生成的fs.img，然后通过mkfs自己生成需要的fs.img，并只选定必要的程序，如下：
![[Pasted image 20231226173745.png]]

我们只装入了init、sh、ls三个用户程序，接着运行整个XV6，当我们运行ls指令，可以看到文件系统中只有如下用户应用程序，这就印证了我们的说法。
![[Pasted image 20231226173836.png]]

# XV6装载到qemu
当我们运行`make qemu`，在Makefile中是如下描述：首先需要生成好内核执行文件与用户应用程序文件，然后通过QEMU（qemu-system-riscv64）指令运行QEMUOPTS相应指令。
![[Pasted image 20231226174015.png]]

指令具体解释可以看GPT，但几个重点就是通过`-kernel`装载内核执行文件，通过`-smp`指定CPU数量，通过`-drive`指定磁盘镜像。

# 总结
通过以上步骤，我们就编译完了整个XV6，并装入QEMU进行了运行，运行结果自然与操作系统内核设计相关，这个请看其他相关内容。