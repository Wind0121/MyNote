# 概述
本节我们主要讲述XV6如何启动以及运行第一个进程，并进入等待输入命令的模式。大致分为以下几个阶段：
![[Pasted image 20231227170908.png]]

# \_entry
根据kernel.ld的链接脚本设定，\_entry位于0x8000000处，是操作系统第一个的入口程序。每个CPU核都会从该程序进入，其主要工作包括：
1. 为每个CPU设置一个栈区，用于执行C代码（暂时不清楚有什么用）
2. 跳转到start.c中的`start()`

# start()
函数`start`执行一些仅在机器模式下允许的配置，然后切换到管理模式，并跳转到main()函数。

# main()
`main`函数开始进行操作系统的各类初始化，其中CPU0负责进行所有初始化，其他CPU在CPU0初始化完毕后才能进行部分初始化。
![[Pasted image 20231227171625.png]]
这里我们只关注CPU0调用的`userinit()`，这个函数将会初始化一个用户进程，之后调用scheduler，会转移到该用户进程执行。

# userinit
`userinit`函数专门用于操作系统的初始化：
1. 首先初始化一个进程，根据`allocproc`函数，该进程的swtch返回地址被设定为`forkret`函数。
2. 接着调用`uvminit`函数，在该进程的虚拟地址0处映射一个物理页，并将初始化程序（静态形式的16进制代码）copy到对应的物理内存
3. 将该进程用户空间返回地址设置为0，这样当进程返回到用户空间时，就会执行设置好的初始化程序。
4. 将进程状态设置为`RUNNABLE`，这样就可以被调度器线程发现并进行切换。

# scheduler
这个函数我们之后会细讲，目前可以知道该函数会找到状态为`RUNNABLE`的进程并进行切换，切换后的地址就是进程swtch返回地址，存储在寄存器`ra`中。

main函数调用scheduler，找到我们设置好的初始化进程，并切换到该进程，之后该进程回到用户空间，并从虚拟地址0开始执行我们copy的初始化程序`initcode`

# initcode
该程序只做一件事情：调用exec(init)，根据exec特性，init.c程序将会覆盖当前线程，因而我们就开始执行用户空间中的init.c程序。

# init
init.c会调用sh.c，用于shell的启动，并停留直到sh.c退出。

# sh
sh.c程序就是我们用于与XV6交互的程序，其先打印一个`$`，表示等待指令输入，如下：
![[Pasted image 20231227172855.png]]

至此我们就完成了XV6的启动，并可以等待指令的输入。



