# 概述
有三种事件会导致中央处理器搁置普通指令的执行，并强制将控制权转移到处理该事件的特殊代码上：
- 系统调用：用户程序执行`ecall`指令要求内核为其做点什么
- 异常：（用户或内核）指令做了一些非法的事情
- 设备中断：一个设备，例如当磁盘硬件完成读或写请求时，向系统表明它需要被关注

处理这些情况的机制被称为Trap。

# Trap中的RISC-V硬件
## RISC-V重要寄存器
- `PC`：程序计数器
- `SATP`：指向当前页表的物理内存地址
- `stvec`：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱
- `sepc`：当发生陷阱时，RISC-V会在这里保存程序计数器`pc`（因为`pc`会被`stvec`覆盖）。`sret`（从陷阱返回）指令会将`sepc`复制到`pc`。内核可以写入`sepc`来控制`sret`的去向
- `scause`： RISC-V在这里放置一个描述陷阱原因的数字
- `sscratch`：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场
- `sstatus`：其中的**SIE**位控制设备中断是否启用。如果内核清空**SIE**，RISC-V将推迟设备中断，直到内核重新设置**SIE**。**SPP**位指示陷阱是来自用户模式还是管理模式，并控制`sret`返回的模式。

## Trap机制中的硬件操作
当需要强制执行陷阱时，RISC-V硬件对所有陷阱类型（计时器中断除外）执行以下操作：
1. 如果陷阱是设备中断，并且状态**SIE**位被清空，则不执行以下任何操作。
2. 清除**SIE**以禁用设备中断。
3. 将`pc`复制到`sepc`。
4. 将当前模式（用户或管理）保存在状态的**SPP**位中。
5. 设置`scause`以反映产生陷阱的原因。
6. 将模式设置为管理模式。
7. 将`stvec`复制到`pc`，从而跳转到`stvec`地址处的指令
8. 在新的`pc`上开始执行。

**请注意**，CPU不会切换到内核页表，不会切换到内核栈，也不会保存除`pc`之外的任何寄存器。内核软件必须执行这些任务。RISC-V这样做是为了给内核软件提供足够的自由度。

# Trap机制：系统调用
## 概述
![[Pasted image 20231229165847.png]]
系统调用情况下的Trap机制如上图

## ecall
在用户空间中，`user.h`头文件中提供了所有系统调用的函数声明，用户程序可以直接调用这些函数，并通过**编译**，并在**链接**阶段找到对应的函数定义。

这些系统调用函数的生成方式在`usys.pl`文件中写明，这是一个脚本文件，用于生成所有系统调用函数在用户空间的入口。经过**编译**后生成对应的目标文件，其汇编形式如下：
![[Pasted image 20231229165417.png]]

每个系统调用函数在用户空间的入口都是将对应系统调用的**编号**写入`a7`寄存器中，随后调用`ecall`指令。告知内核进入Trap机制，同时**RISC-V硬件**会完成其工作。

## uservec
执行`ecall`指令后，**RISC-V硬件**将`stvec`复制到`pc`，从而跳转到`stvec`地址处的程序，这就是`kernel/trampoline.S`中的`uservec`函数。

该函数步骤如下：
1. 将该进程用户空间的所有寄存器存放在`proc->trapframe`中
2. 从`proc->trapframe`中读取`kernel_sp`，即内核栈指针
3. 从`proc->trapframe`中读取`kernel_hartid`，即进程运行的CPU ID
4. 从`proc->trapframe`中读取`kernel_trap`，即`usertrap`函数地址
5. 从`proc->trapframe`中读取`kernel_satp`，即内核页表的物理地址
6. 将内核页表物理地址写入`satp`寄存器中，无缝衔接到内核空间
7. 跳转到`usertrap`函数

>Q：为什么`stvec`存储了`uservec`函数的地址？
>A：答案在`usertrapret`函数中
>
>Q：将寄存器值存放到`proc->trapframe`时使用了`sscratch`寄存器，为什么该寄存器存着TRAPFRAME的虚拟地址？
>A：答案在`userret`函数中
>
>Q：为什么能无缝衔接到内核空间，而不是因为页表出错而直接程序崩溃？
>A：所有进程的用户空间和内核空间的TRAMPOLINE的虚拟地址相同，因而从用户页表切换到内核页表不会影响TRAMPOLINE虚拟地址的翻译。
>
>Q：为什么切换内核空间后就不能再使用TRAPFRAME的虚拟地址
>A：因为内核空间中没有映射TRAPFRAME，因而相同的虚拟地址映射的不是TRAPFRAME

# usertrap
该函数负责对来自用户空间Trap的情况进行分类处理，本次我们只讨论系统调用的处理情况。

该函数步骤如下：
1. 将`kernelvec`函数地址写入`stvec`中，这样来自内核的中断或yi'c





