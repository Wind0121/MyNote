- [[#概述|概述]]
- [[#procinit|procinit]]
- [[#fork|fork]]
	- [[#fork#allocproc|allocproc]]
- [[#exec|exec]]
- [[#malloc(sbrk)|malloc(sbrk)]]
- [[#exit|exit]]
- [[#wait|wait]]
	- [[#wait#freeproc|freeproc]]
# 概述
![[Pasted image 20231228172121.png]]
本节我们讲述进程从创建到执行程序到最后退出并被清空的全流程，其中涉及一些其他部分的函数调用，这里只做功能介绍，而不深入探究。

# procinit
该函数负责在操作系统初始化的过程中对进程池进行初始化，因而会在main函数中进行调用。

该函数功能如下：
- 遍历进程池的所有进程
- 对每一个进程调用`initlock`初始化进程的`lock`
- 为每个进程分配一个物理页，并将其映射到对应进程的内核栈区域
	- 首先通过`KSTACK`找到该进程在内核页表中的映射的虚拟地址
	- 调用`kvmmap`将该虚拟地址映射到分配的物理页
- 每个进程的内核栈区域之间都有一个未被映射的页作为guard page，其在kernel_pagetable中的pte有效位标志无效

# fork
fork是一个系统调用，用于创建一个新的进程，并复制当前进程的所有信息。sh进程负责接收输入命令，如果需要执行程序，sh进程会调用fork新建一个进程，并在该进程中调用exec执行程序，exec系统调用会覆盖当前进程。

`fork`函数步骤如下：
1. 调用`allocproc`函数，新建一个空白子进程
2. 将当前进程的用户页表**深拷贝**到子进程的用户页表中，包括pte的拷贝和对应物理地址上的内容拷贝。
3. 复制进程的大小`sz`
4. 设置子进程的`parent`为当前进程
5. 将当前进程`trapframe`拷贝到子进程的`trapframe`中
6. 设置子进程`trapframe`的`a0`寄存器为0，表示返回值为0，这样当该子进程返回到用户空间中，返回值就是0，而父进程的返回值是子进程的`pid`，可以用于区分父进程和子进程
7. 将父进程打开的文件`ofile`拷贝到子进程中，并拷贝当前所在路径`cwd`
8. 拷贝两个进程的名字
9. 设置子进程的状态为`RUNNABLE`，这样就可以被调度器切换
10. 释放子进程的`lock`
11. 返回子进程的`pid`，这样父进程返回用户空间时得到的系统调用返回值为子进程`pid`

## allocproc
`allocproc`函数用于从进程池中选出一个空闲进程并进行初始化，从而分配一个可用的进程。

该函数步骤如下：
1. 遍历进程池，找到状态为`UNUSED`的进程，否则返回0
2. 通过`allocpid`函数分配下一个进程的进程号`pid`
3. 给该进程分配`trapframe`的物理页，并存放在`p->trapframe`中
4. 通过调用`proc_pagetable`函数，给该进程创建一个用户页表，并完成`TRAMPOLINE`和`TRAPFRAME`的两个物理页在用户页表中的映射，位于用户虚拟空间的顶端
5. 清空该进程上下文`contexe`，并把`ra`寄存器的值设为`forkret`函数，`sp`寄存器的值设为`p->kstack + PGSIZE`，分别表示该切换该进程后的返回地址和在内核中的栈顶指针
6. 返回该进程，并确保持有该结构的`lock`

# exec
`exec`系统调用可以执行一个用户程序，并且将用户程序覆盖当前进程。因而`sh`进程调用`exec`系统调用之前都需要`fork`一个子进程，并在子进程中进行操作。

该函数步骤如下：
1. 调用`proc_pagetable`函数，新建一个空的用户页表
2. 通过文件系统相关函数找到对应路径的用户程序，并根据ELF格式将该用户程序加载到用户页表，期间需要为用户程序分配内存，并从虚拟地址0开始进行映射
3. 在用户页表的用户程序地址上部，分配两个物理页，下面一个作为guard page，上面一个作为用户栈（可以参考用户地址空间）
4. 将exec的参数argv进行入栈，并将所有参数的指针数组`ustack`入栈，设置`p->trapframe->a1 = sp`，这样就设置了`main(argc, argv)`中的argv参数
5. 将用户页表进行替换，旧的用户页表直接释放
6. 设置`p->trapframe->epc = elf.entry`，这样就设置了进程的返回地址，同时也是新程序的入口地址

# malloc(sbrk)
`malloc`是用户空间中的一个辅助函数，也就是熟悉的堆内存分配函数，其内部调用了`sbrk`系统调用，用于在用户空间的堆区域申请分配内存。

`sbrk`系统调用又会调用`growproc`函数，该函数实际就是在栈区域上方的堆区域向上扩展，分配内存。

# exit
`exit`是一个系统调用，用于在用户程序中退出程序，同时也是退出进程。exit并不会真正释放进程的内容，因为不可能在当前进程中释放当前进程的内容，因而exit只是将状态设置为`ZOMBIE`，然后等待父进程wait将子进程真正释放。

该函数步骤如下：
1. 关闭当前进程打开的所有文件（涉及文件系统函数调用）
2. 唤醒"初始进程“，因为可能会有用
3. 按照父进程->子进程的顺序上锁，保证不会死锁
4. 将当前进程的所有子进程的parent重新设置为”初始进程“，因为当前进程要退出了，管不了子进程。
5. 将当前进程的状态设置了`ZOMBIE`，并唤醒父进程
6. 直接调用sched函数，切换进程，永远不返回

**关于上锁顺序**
exit和wait都遵循父进程->子进程的上锁顺序，这样就不会发生死锁。同时也说明只有父进程才能修改子进程的内容。

# wait
`wait`是一个系统调用，用于在用户程序中等待任意一个子进程`exit`，然后就会将该子进程进行真正的释放。

该函数步骤如下：
1. 遍历整个线程池，查看是否有当前进程的子进程，如果没有就直接退出
2. 如果有当前进程的子进程，且子进程尚未`exit`，即状态还不是`ZOMBIE`，则调用`sleep`进入睡眠状态
3. 如果子进程已经`eixt`，调用`freeproc`函数释放子进程，并返回

## freeproc
`freeproc`函数负责该进程申请的所有物理内存都进行释放，然后重置线程状态，并回归线程池。

该函数步骤如下：
1. 调用`kfree`函数，释放该进程的`trapframe`
2. 释放用户页表所有叶子PTE对应的物理页，除了`TRAMPOLINE`和`TRAPFRAME`（trapframe已经释放）并释放页表所占用的物理页
3. 将线程结构体的所有变量重置为0，并将状态设置为`UNUSED`，这样就可以被重新分配





