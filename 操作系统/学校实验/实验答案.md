# kernel/strap.c
```C
/*  
 * Utility functions for trap handling in Supervisor mode.  
 */  
  
#include "riscv.h"  
#include "process.h"  
#include "strap.h"  
#include "syscall.h"  
  
#include "spike_interface/spike_utils.h"  
  
//  
// handling the syscalls. will call do_syscall() defined in kernel/syscall.c  
//  
static void handle_syscall(trapframe *tf) {  
  // tf->epc points to the address that our computer will jump to after the trap handling.  
  // for a syscall, we should return to the NEXT instruction after its handling.  
  // in RV64G, each instruction occupies exactly 32 bits (i.e., 4 Bytes)  
  tf->epc += 4;  
  
  // TODO (lab1_1): remove the panic call below, and call do_syscall (defined in  
  // kernel/syscall.c) to conduct real operations of the kernel side for a syscall.  
  // IMPORTANT: return value should be returned to user app, or else, you will encounter  
  // problems in later experiments!  
  tf->regs.a0 = do_syscall(tf->regs.a0,tf->regs.a1,tf->regs.a2,tf->regs.s3,tf->regs.a4,tf->regs.a5,tf->regs.a6,tf->regs.a7);  
  
}  
  
//  
// global variable that store the recorded "ticks". added @lab1_3  
static uint64 g_ticks = 0;  
//  
// added @lab1_3  
//  
void handle_mtimer_trap() {  
  sprint("Ticks %d\n", g_ticks);  
  // TODO (lab1_3): increase g_ticks to record this "tick", and then clear the "SIP"  
  // field in sip register.  
  // hint: use write_csr to disable the SIP_SSIP bit in sip.  
  g_ticks++;  
  write_csr(sip,read_csr(sip) & (~SIP_SSIP));  
  
}  
  
//  
// kernel/smode_trap.S will pass control to smode_trap_handler, when a trap happens  
// in S-mode.  
//  
void smode_trap_handler(void) {  
  // make sure we are in User mode before entering the trap handling.  
  // we will consider other previous case in lab1_3 (interrupt).  
  if ((read_csr(sstatus) & SSTATUS_SPP) != 0) panic("usertrap: not from user mode");  
  
  assert(current);  
  // save user process counter.  
  current->trapframe->epc = read_csr(sepc);  
  
  // if the cause of trap is syscall from user application.  
  // read_csr() and CAUSE_USER_ECALL are macros defined in kernel/riscv.h  
  uint64 cause = read_csr(scause);  
  
  // we need to handle the timer trap @lab1_3.  
  if (cause == CAUSE_USER_ECALL) {  
    handle_syscall(current->trapframe);  
  } else if (cause == CAUSE_MTIMER_S_TRAP) {  //soft trap generated by timer interrupt in M mode  
    handle_mtimer_trap();  
  } else {  
    sprint("smode_trap_handler(): unexpected scause %p\n", read_csr(scause));  
    sprint("            sepc=%p stval=%p\n", read_csr(sepc), read_csr(stval));  
    panic( "unexpected exception happened.\n" );  
  }  
  
  // continue (come back to) the execution of current process.  
  switch_to(current);  
}
```

# kernel/machine/mtrap.c
```C
#include "kernel/riscv.h"  
#include "kernel/process.h"  
#include "spike_interface/spike_utils.h"  
  
static void handle_instruction_access_fault() { panic("Instruction access fault!"); }  
  
static void handle_load_access_fault() { panic("Load access fault!"); }  
  
static void handle_store_access_fault() { panic("Store/AMO access fault!"); }  
  
static void handle_illegal_instruction() { panic("Illegal instruction!"); }  
  
static void handle_misaligned_load() { panic("Misaligned Load!"); }  
  
static void handle_misaligned_store() { panic("Misaligned AMO!"); }  
  
//  
// handle_mtrap calls a handling function according to the type of a machine mode interrupt (trap).  
//  
void handle_mtrap() {  
  uint64 mcause = read_csr(mcause);  
  switch (mcause) {  
    case CAUSE_FETCH_ACCESS:  
      handle_instruction_access_fault();  
      break;  
    case CAUSE_LOAD_ACCESS:  
      handle_load_access_fault();  
    case CAUSE_STORE_ACCESS:  
      handle_store_access_fault();  
      break;  
    case CAUSE_ILLEGAL_INSTRUCTION:  
      // TODO (lab1_2): call handle_illegal_instruction to implement illegal instruction  
      // interception, and finish lab1_2.  
      handle_illegal_instruction();  
  
      break;  
    case CAUSE_MISALIGNED_LOAD:  
      handle_misaligned_load();  
      break;  
    case CAUSE_MISALIGNED_STORE:  
      handle_misaligned_store();  
      break;  
  
    default:  
      sprint("machine trap(): unexpected mscause %p\n", mcause);  
      sprint("            mepc=%p mtval=%p\n", read_csr(mepc), read_csr(mtval));  
      panic( "unexpected exception happened in M-mode.\n" );  
      break;  
  }  
}
```

