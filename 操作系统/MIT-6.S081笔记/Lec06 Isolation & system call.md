# Trap机制
用户空间和内核空间的切换被称为Trap，通常发生在以下情况：
- 程序执行系统调用
- 程序出现了类似page fault、运算时除以0的错误
- 一个设备触发了中断使得当前程序运行需要响应内核设备驱动

**重要寄存器：**
- PC：程序计数器
- SATP：指向当前页表的物理内存地址
- `stvec`：内核在这里写入其陷阱处理程序的地址；RISC-V跳转到这里处理陷阱
- `sepc`：当发生陷阱时，RISC-V会在这里保存程序计数器`pc`（因为`pc`会被`stvec`覆盖）。`sret`（从陷阱返回）指令会将`sepc`复制到`pc`。内核可以写入`sepc`来控制`sret`的去向
- `scause`： RISC-V在这里放置一个描述陷阱原因的数字
- `sscratch`：内核在这里放置了一个值，这个值在陷阱处理程序一开始就会派上用场
- mode标志位：这个标志位表明了当前是supervisor mode还是user mode。当我们在运行Shell的时候，自然是在user mode

在trap的最开始，CPU的所有状态都设置成运行用户代码而不是内核代码。在trap处理的过程中，我们实际上需要更改一些这里的状态，或者对状态做一些操作。这样我们才可以运行系统内核中普通的C程序。接下来我们先来预览一下需要做的操作：
1. 我们需要保存32个用户寄存器。因为很显然我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。
2. 程序计数器也需要在某个地方保存，它几乎跟一个用户寄存器的地位是一样的，我们需要能够在用户程序运行中断的位置继续执行用户程序。
3. 我们需要将mode改成supervisor mode，因为我们想要使用内核中的各种各样的特权指令
4. SATP寄存器现在正指向user page table，而user page table只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的内存映射。所以在运行内核代码之前，我们需要将SATP指向kernel page table。
5. 我们需要将堆栈寄存器指向位于内核的一个地址，因为我们需要一个堆栈来调用内核的C函数。
6. 一旦我们设置好了，并且所有的硬件状态都适合在内核中使用， 我们需要跳入内核的C代码。

**mode标志位：**
当我们在用户空间时，这个标志位对应的是user mode，当我们在内核空间时，这个标志位对应supervisor mode。supervisor mode模式有以下特权：
- 读写控制寄存器
	- 读写SATP寄存器，也就是page table的指针
	- 读写STVEC，也就是处理trap的内核指令地址
	- 读写SEPC，保存当发生trap时的程序计数器
	- 读写SSCRATCH
- 可以使用PTE_U为0的PTE

# Trap代码执行流程

