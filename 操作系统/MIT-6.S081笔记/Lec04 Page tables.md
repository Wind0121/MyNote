# 地址空间（Address Spaces）
给包括内核在内的所有应用程序提供专属的地址空间。对每个程序而言，它们的地址空间都是从0到某个地址结束。因而我们可以将地址空间看作一种抽象概念，可以把它想成是一个盒子，程序就只能在这个盒子里边使用，因而实现了隔离性。

在课本第二章的**2.5 进程概述**中也有提到，为了帮助加强隔离，进程抽象给程序提供了一种错觉，即它有自己的专用机器。进程为程序提供了一个看起来像是私有内存系统或地址空间的东西，其他进程不能读取或写入。进程还为程序提供了看起来像是自己的CPU来执行程序的指令。

![[Pasted image 20230912111722.png]]

顺着这个思路，我们就能得出要在一个物理内存上，创建不同的地址空间，因为归根到底，我们使用的还是一堆存放了内存信息的DRAM芯片。对此，我们使用了页表。

# 页表（Page Table）
## 抽象概念
既然要创建地址空间，我们就肯定要使用虚拟地址，并将这个虚拟地址映射到物理地址。

对于任何一条带地址的指令，其中的地址应该认为是虚拟内存地址而不是物理地址。虚拟内存地址会被转到内存管理单元（MMU，Memory Management Unit）

内存管理单元会将虚拟地址翻译成物理地址。之后这个物理地址会被用来索引物理内存，并从物理内存加载，或者向物理内存存储数据。

为了能够完成虚拟内存地址到物理内存地址的翻译，MMU会有一个表单，表单中，一边是虚拟内存地址，另一边是物理内存地址。（类似于一个键值对）

通常来说，内存地址对应关系的表单也保存在物理内存中。所以CPU中需要有一些寄存器用来存放表单在物理内存中的地址。这个寄存器就是SATP（RISC-V）。这样，CPU就可以告诉MMU，可以从哪找到将虚拟内存地址翻译成物理内存地址的表单。

![[Pasted image 20230912112741.png]]

>page table保存在物理内存中，MMU只是会去查看page table，然后完成翻译。

每个应用程序都有自己独立的表单，并且这个表单定义了应用程序的地址空间。所以当操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单。

以上就是我们对页表的一个抽象理解，这并不是实际的实现，但我们可以通过这种抽象的方式理解页表在建立地址空间中的作用。

## 实际情况








