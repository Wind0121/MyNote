# 地址空间（Address Spaces）
给包括内核在内的所有应用程序提供专属的地址空间。对每个程序而言，它们的地址空间都是从0到某个地址结束。因而我们可以将地址空间看作一种抽象概念，可以把它想成是一个盒子，程序就只能在这个盒子里边使用，因而实现了隔离性。

在课本第二章的**2.5 进程概述**中也有提到，为了帮助加强隔离，进程抽象给程序提供了一种错觉，即它有自己的专用机器。进程为程序提供了一个看起来像是私有内存系统或地址空间的东西，其他进程不能读取或写入。进程还为程序提供了看起来像是自己的CPU来执行程序的指令。

![[Pasted image 20230912111722.png]]

顺着这个思路，我们就能得出要在一个物理内存上，创建不同的地址空间，因为归根到底，我们使用的还是一堆存放了内存信息的DRAM芯片。对此，我们使用了页表。

# 页表（Page Table）
## 抽象概念
既然要创建地址空间，我们就肯定要使用虚拟地址，并将这个虚拟地址映射到物理地址。

对于任何一条带地址的指令，其中的地址应该认为是虚拟内存地址而不是物理地址。虚拟内存地址会被转到内存管理单元（MMU，Memory Management Unit）

内存管理单元会将虚拟地址翻译成物理地址。之后这个物理地址会被用来索引物理内存，并从物理内存加载，或者向物理内存存储数据。

为了能够完成虚拟内存地址到物理内存地址的翻译，MMU会有一个表单，表单中，一边是虚拟内存地址，另一边是物理内存地址。（类似于一个键值对）

通常来说，内存地址对应关系的表单也保存在物理内存中。所以CPU中需要有一些寄存器用来存放表单在物理内存中的地址。这个寄存器就是SATP（RISC-V）。这样，CPU就可以告诉MMU，可以从哪找到将虚拟内存地址翻译成物理内存地址的表单。

![[Pasted image 20230912112741.png]]

>page table保存在物理内存中，MMU只是会去查看page table，然后完成翻译。

每个应用程序都有自己独立的表单，并且这个表单定义了应用程序的地址空间。所以当操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单。

以上就是我们对页表的一个抽象理解，这并不是实际的实现，但我们可以通过这种抽象的方式理解页表在建立地址空间中的作用。

## 实际情况
基于上述的概念，我们可以得到下面一张图，这张图会贴近实际，但还不是最终实现：
![[Pasted image 20230912113725.png]]
1. 首先XV6基于Sv39 RISC-V运行，这意味着它只使用64位虚拟地址的低39位；而高25位不使用。
2. 在RISC-V中，物理内存地址是56bit。大多数主板还不支持2^56这么大的物理内存。
3. RISC-V页表在**逻辑**上是一个由 $2^{27}$ 个页表条目（Page Table Entries/PTE）组成的数组。这 $2^{27}$ 个页表条目由虚拟地址中的Index进行指引。
4. 每个PTE包含一个44位的物理页码（Physical Page Number/PPN）和10位的标志。
5. 我们用44位的物理页码PPN找到物理页，这个物理页是 $2^{12}$ 大小，也就是4096字节。
6. 我们使用虚拟地址末尾的12位作为物理页中的偏移，从而在4096字节中找到需要的地址。这就是我们翻译后的物理地址。

**Q/A**
>Q：图中的物理地址56bit又是根据什么确定的？
>A：这是由硬件设计人员决定的。所以RISC-V的设计人员认为56bit的物理内存地址是个不错的选择。可以假定，他们是通过技术发展的趋势得到这里的数字。比如说，设计是为了满足5年的需求，可以预测物理内存在5年内不可能超过2^56这么大。或许，他们预测是的一个小得多的数字，但是为了防止预测错误，他们选择了像2^56这么大的数字。
>Q：PTE中为什么还有10位空缺
>A：同样是保留用途，以后可以扩展物理地址

通过前面的讲解，我们了解了页表在**逻辑**上的实现，但是目前的设计还不能满足实际的需求。在上图中，Page table有 $2^{27}$ 个条目，而每个进程都会有自己的Page table，这就是一个相当大的数字，会消耗大量的内存，而这其中又有很多条目实际是没有使用的，因而我们需要做出改进。

实际中，page table是一个多级的结构。下图是一个真正的RISC-V page table结构和硬件实现。
![[Pasted image 20230912115449.png]]
1. 之前提到的27位Index，实际上分为三段L2、L1、L0，分别为9位。
2. SATP存储最高一级Page Directory（与Page Table相同），L2为最高一级Page Directory的偏移。
3. 上一级Page Directory的PTE中存储的PPN，是下一级Page Directory的物理地址。然后又可以根据虚拟地址中的L字段进行寻找。
4. 最终我们就可以找到实际的物理地址，完成翻译。

从某种程度上，三级映射的方式与一级映射没有区别，但优点就在于每个Page Directory的大小比较小。举个例子，如果地址空间只使用了一个物理地址，那么我们就需要三个PTE，也就是三个Page Directory，总计为 $3*4096$字节


>Q：为什么44位的PPN能代表下一级Page Directory的物理地址
>A：在三级Page Directory中，一个Page Directory有 $2^9$ 即512个PTE，每个PTE都是64位，即8字节，的条目，因而整个Page Directory的大小就是4096字节，与之前概念中44位PPN寻找物理地址的方式相同。








