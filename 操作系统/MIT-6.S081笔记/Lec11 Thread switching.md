# 线程概述
在XV6中，一个进程只能有一个线程，因而在这节课中，我们可以认定线程就是进程。但对于linux这样操作系统，一个进程可以拥有多个线程，这种时候就需要区分。

线程就是单个串行执行代码的单元，它只占用一个CPU并且以普通的方式一个接一个的执行指令。

今天我们要讲的多线程并行运行的策略就是：一个CPU在多个线程之间切换。

XV6中包含多种线程：
1. 用户线程：每个用户进程都包含一个线程，并有独立的内存空间。
2. 内核线程：每个用户进程都有一个内核线程负责执行内核态代码，所有的内核线程都共享内核内存（都用的同一个内核页面）
3. 调度线程：每个CPU都有一个调度线程，运行调度程序，之后会看到。

# XV6线程调度
在XV6中，一种线程调度的方式是定时器中断：每个CPU核上都有一个硬件设备，定时产生中断，从而用户进程会进入内核trap，然后调用yield()出让CPU，这里就实现了线程切换。

在执行线程调度的时候，操作系统需要能区分几类线程：
- 当前在CPU上运行的线程——RUNNING
- 一旦CPU有空闲时间就想要运行在CPU上的线程——RUNABLE
- 以及不想运行在CPU上的线程，因为这些线程可能在等待I/O或者其他事件——SLEEPING

本节我们将讨论RUNNING与RUNABLE两类线程的切换。

# XV6线程切换
下面我们介绍从一个RUNNING线程切换到RUNABLE线程的过程：
1. 定时器中断强迫线程从用户空间进程切换到内核，trampoline代码将用户寄存器保存trapframe中。
2. 执行yield()函数，并调用swtch()函数，将当前内核线程的寄存器（在cpu中）保存到proc->context中，并将调度器线程的寄存器加载到cpu中。这样我们就切换到调度器线程了。
3. 调度器线程在scheduler()中的swtch()返回，找到下一个RUNABLE线程，再次执行swtch()函数，切换到对应线程。
4. 这样就完成了一个线程的切换。

# XV6线程切换代码
