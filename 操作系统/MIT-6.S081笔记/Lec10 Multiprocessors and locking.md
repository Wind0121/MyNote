# race condition（竞态）
操作系统中存在这样的情况，即一个CPU读取数据结构，而另一个CPU正在更新它，甚至多个CPU同时更新相同的数据；如果不仔细设计，这种并行访问可能会产生不正确的结果或损坏数据结构。即使在单处理器上，内核也可能在许多线程之间切换CPU，导致它们的执行交错。

竞态条件是指多个进程读写某些共享数据（至少有一个访问是写入）的情况。

避免竞争的通常方法是使用锁，锁确保互斥。

# 锁如何避免race condition？
锁就是一个对象，就像其他在内核中的对象一样，有一个结构体叫做lock，它包含了一些字段，这些字段中维护了锁的状态。

锁有以下功能：
- 保护系统中的不变量。不变量是跨操作维护的数据结构的属性。操作可能暂时违反不变量，但必须在完成之前重新建立它们。这就需要在release之前完成。

锁有非常直观的API：
- acquire，接收指向lock的指针作为参数。acquire确保了在任何时间，只会有一个进程能够成功的获取锁。
- release，也接收指向lock的指针作为参数。release释放当前进程持有的锁，这样其他进程才能获取该锁。

锁的acquire和release之间的代码，通常被称为critical section。类似于关键区间，其原因如下：
	在critical section中，系统以原子的方式执行共享数据的更新。即要么会一起执行，要么一条也不会执行。





