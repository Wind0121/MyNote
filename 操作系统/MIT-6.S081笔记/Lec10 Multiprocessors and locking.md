# race condition（竞态）
操作系统中存在这样的情况，即一个CPU读取数据结构，而另一个CPU正在更新它，甚至多个CPU同时更新相同的数据；如果不仔细设计，这种并行访问可能会产生不正确的结果或损坏数据结构。即使在单处理器上，内核也可能在许多线程之间切换CPU，导致它们的执行交错。

竞态条件是指多个进程读写某些共享数据（至少有一个访问是写入）的情况。

避免竞争的通常方法是使用锁，锁确保互斥。

# 锁如何避免race condition？
锁就是一个对象，就像其他在内核中的对象一样，有一个结构体叫做lock，它包含了一些字段，这些字段中维护了锁的状态。

锁有以下功能：
- 保护系统中的不变量。不变量是跨操作维护的数据结构的属性。操作可能暂时违反不变量，但必须在完成之前重新建立它们。这就需要在release之前完成。
- 实现串行化并发的临界区域。在锁保护的一段代码中，同时只有一个进程在执行。
- 限制性能。串行化必定会导致性能的下降。当有多个进程需要执行时，只有一个进程能执行，其他进程都需要等待。

锁有非常直观的API：
- acquire，接收指向lock的指针作为参数。acquire确保了在任何时间，只会有一个进程能够成功的获取锁。
- release，也接收指向lock的指针作为参数。release释放当前进程持有的锁，这样其他进程才能获取该锁。

锁的acquire和release之间的代码，通常被称为critical section。类似于关键区间，其原因如下：
- 在critical section中，系统以原子的方式执行共享数据的更新。即要么会一起执行，要么一条也不会执行。

# 什么时候使用锁？
一个非常保守同时也非常简单的规则是：
- 如果两个进程访问了一个共享的数据结构，并且其中一个进程会更新共享的数据结构，那么就需要对于这个共享的数据结构加锁。

#  锁的特性
锁的三个作用：
- 锁可以避免丢失更新。
- 锁可以打包多个操作，使它们具有原子性。
- 锁可以维护共享数据结构的不变性。

# 死锁
同一个进程的死锁例子：
- 一个进程首先acquire一个锁，然后进入到critical section；在critical section中，再acquire同一个锁；第二个acquire必须要等到第一个acquire状态被release了才能继续执行，但是不继续执行的话又走不到第一个release，所以程序就一直卡在这了。

多个进程的死锁例子：
- 假设xv6中的两个代码路径需要锁A和B，但是代码路径1按照先A后B的顺序获取锁，另一个路径按照先B后A的顺序获取锁。假设线程T1执行代码路径1并获取锁A，线程T2执行代码路径2并获取锁B。接下来T1将尝试获取锁B，T2将尝试获取锁A。两个获取都将无限期阻塞，因为在这两种情况下，另一个线程都持有所需的锁，并且不会释放它，直到它的获取返回。

解决死锁的方法就是对锁进行排序，多个进程都按同一顺序进行上锁，就能解决死锁的问题。

遵守全局死锁避免的顺序可能会出人意料地困难。有时锁顺序与逻辑程序结构相冲突，例如，也许代码模块M1调用模块M2，但是锁顺序要求在M1中的锁之前获取M2中的锁。有时锁的身份是事先不知道的，也许是因为必须持有一个锁才能发现下一个要获取的锁的身份。这种情况在文件系统中出现，因为它在路径名称中查找连续的组件。

# 自旋锁（Spin lock）的实现








