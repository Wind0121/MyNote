## 操作系统的任务
1. 在多个程序之间共享一台计算机，并提供比硬件本身支持的更有用的服务
2. 管理和抽象底层硬件，例如文字处理器不需要关心使用哪种类型的磁盘硬件
3. 在多个程序之间共享硬件，这样它们就可以(或者看起来可以)同时运行
4. 为程序提供了可控的交互方式，这样它们就可以共享数据或者一起工作

## 接口设计的两个矛盾点
1. 一方面，我们希望接口简单明了，因为这样更利于正确使用
2. 另一方面，我们可能倾向于为应用程序提供许多复杂的特性

这样尽管接口是简单的，我们却能将多个接口结合起来组成复杂的用例，从而实现复杂的特性。同时也能提供通用性

## 内核与进程
如下图所示，xv6采用传统的内核形式（内核是一个特殊的程序，为正在运行的程序提供服务）。每个正在运行的程序，称为进程，都有包含指令、数据和堆栈的内存。一台给定的计算机通常有许多进程，但只有一个内核。
![[Pasted image 20230816105530.png]]
内核拥有操控硬件的权限，因而用户空间的进程执行某些任务需要使用内核服务时，就要调用操作系统接口提供的系统调用，系统调用会进入内核并执行服务，随后返回。因此，一个进程在用户空间和内核空间之间交替执行。

## Shell
Shell是一个普通的程序，它从用户那里读取命令并执行它们。Shell是一个用户程序，而不是内核的一部分。这一事实说明了系统调用接口的强大之处：shell没有什么特别之处。这也意味着shell很容易替换。

#   1.1 进程和内存
## 进程
Xv6进程由用户空间内存(指令、数据和堆栈)和对内核私有的每个进程状态组成。内核利用进程id或PID标识每个进程。

## fork
一个进程可以使用fork系统调用创建一个新的进程。Fork创建了一个新的进程，其内存内容与调用进程（称为父进程）完全相同，称其为子进程。Fork在父子进程中都返回值。在父进程中，fork返回子类的PID；在子进程中，fork返回零。

**注：子进程会在fork调用的返回处开始执行，且子进程在返回处的fork返回值为0，但是子进程可以在之后继续fork，这样就又创建了子进程，进而可以创建进程树**

最初子进程与父进程有着相同的内存内容，但是二者在运行中拥有不同的内存空间和寄存器。

`fork`复制了文件描述符表，但是每个基础文件偏移量在父文件和子文件之间是共享的，比如下面的程序：

```C
if (fork() == 0) {
    write(1, "hello ", 6);
    exit(0);
} else {
    wait(0);
    write(1, "world\n", 6);
}
```
最后的写入结果为`hello world`。父进程中的写操作(由于等待，只有在子进程完成后才运行)在子进程停止写入的位置进行。

## exec
`exec`系统调用使用从文件系统中存储的文件所加载的新内存映像替换调用进程的内存。（百度百科：根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件）该文件必须有特殊的格式，它指定文件的哪部分存放指令，哪部分是数据，以及哪一条指令用于启动等等。**xv6使用ELF格式（将会在第三章详细讨论）。**

#   1.2 I/O和文件描述符
## 文件描述符
文件描述符是一个小整数(small integer)，表示进程可以读取或写入的由内核管理的对象。进程可以通过打开一个文件、目录、设备，或创建一个管道，或复制一个已存在的描述符来获得一个文件描述符。

在内部，xv6内核使用文件描述符作为每个进程表的索引，这样每个进程都有一个从零开始的文件描述符的私有空间。

按照惯例，进程从文件描述符0读取（标准输入），将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）。

## close
`close`系统调用释放一个文件描述符，使其可以被未来使用的`open`、`pipe`或`dup`系统调用重用。新分配的文件描述符总是当前进程中编号最小的未使用描述符。

下面是shell运行命令`cat < input.txt`的代码的简化版本。
```C
char* argv[2];
argv[0] = "cat";
argv[1] = 0;
if (fork() == 0) {
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}
```
在子进程关闭文件描述符0之后，`open`保证使用新打开的*input.txt*：0的文件描述符作为最小的可用文件描述符。`cat`然后执行文件描述符0(标准输入)，但引用的是*input.txt*。父进程的文件描述符不会被这个序列改变，因为它只修改子进程的描述符。

在这个过程中，cat实际上不知道重定向的事情，他要做的就是从文件描述符0中读取，然后向文件描述符1进行输出。Unix通过这种简单的方式实现了I/O重定向。

## fork与exec分离的用处
现在应该很清楚为什么`fork`和`exec`分离的用处了：在这两个调用之间，shell有机会对子进程进行I/O重定向，而不会干扰主shell的I/O设置。

## dup
`dup`系统调用复制一个现有的文件描述符，返回一个引用自同一个底层I/O对象的新文件描述符。两个文件描述符共享一个偏移量，就像fork复制的文件描述符一样。（说白了就是新建了一个引用，且和fork一样共享偏移量）

## 小结
文件描述符是一个强大的抽象，因为它们隐藏了它们所连接的细节：写入文件描述符1的进程可能写入文件、设备（如控制台）或管道。

#   1.3 管道
管道是作为一对文件描述符公开给进程的小型内核缓冲区，一个用于读取，一个用于写入。将数据写入管道的一端使得这些数据可以从管道的另一端读取。管道为进程提供了一种通信方式。

下面的示例代码使用连接到管道读端的标准输入来运行程序`wc`，该示例**非常重要**。
```C
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if (fork() == 0) {
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
} else {
    close(p[0]);
    write(p[1], "hello world\n", 12);
    close(p[1]);
}
```
程序调用`pipe`，创建一个新的管道，并在数组p中记录读写文件描述符，其中`p[0]` 为读取端，`p[1]`为写入端。在`fork`之后，父子进程都有指向管道的文件描述符。子进程先close文件描述符0，然后利用dup将文件描述符0重新指向管道读取端`p[0]`，然后又关闭了`p[0]`，这样就实现了标准输入就是管道读取端。

如果没有可用的数据，则管道上的`read`操作将会进入等待，直到有新数据写入或所有指向写入端的文件描述符都被关闭，在后一种情况下，`read`将返回0，就像到达数据文件的末尾一样。事实上，`read`在新数据不可能到达前会一直阻塞，这是子进程在执行上面的`wc`之前关闭管道的写入端非常重要的一个原因：如果wc的文件描述符之一指向管道的写入端，wc将永远看不到文件的结束。

XV6在实现PIPE时，同时创建两个子进程，分别执行管道左端（写入）和管道右端（读取）的指令，父进程则等待两个子进程完成。因此，Shell可以创建一个进程树。这个树的叶子是命令，内部节点是等待左右两个子进程完成的进程。

#  1.4 文件系统
通常来说，shell中执行命令都需要创建一个子进程来执行，一个例外是`cd`指令。`cd` 必须更改shell的当前工作目录，因而可以在shell(**_user/sh.c_**:160)中看到，单独对cd指令进行了处理。

一个文件的名字和文件本身是不同的;同一个底层文件（叫做inode，索引结点）可以有多个名字（叫做link，链接）。每个链接都由目录中的一个条目组成;该条目包含一个文件名和一个inode引用。Inode保存有关文件的元数据（用于解释或帮助理解信息的数据），包括其类型(文件/目录/设备)、长度、文件内容在磁盘上的位置以及指向文件的链接数。
（说白了还是一个引用的问题）