中断对应的场景很简单，就是硬件想要得到操作系统的关注。例如网卡收到了一个packet，网卡会生成一个中断；用户通过键盘按下了一个按键，键盘会产生一个中断。操作系统需要做的是，保存当前的工作，处理中断，处理完成之后再恢复之前的工作。

很显然，中断、系统调用、page fault都是用的同一套trap机制。但中断也和系统调用有所不同：
1. asynchronous（异步）：当硬件生成中断时，Interrupt handler与当前运行的进程在CPU上没有任何关联。但如果是系统调用的话，系统调用发生在运行进程的context下。
2. concurrency（并发）：对于中断来说，CPU和生成中断的设备是并行的在运行。网卡自己独立的处理来自网络的packet，然后在某个时间点产生中断，但是同时，CPU也在运行。
3. program device（编程设备）：设备的编程包含了它有什么样的寄存器，它能执行什么样的操作，在读写控制寄存器的时候，设备会如何响应。

本节课我们会讨论：
- console中的提示符“$ ”是如何显示出来的（控制台输入）（都是相对于内核的）
- 如果你在键盘输入“ls”，这些字符是怎么最终在console中显示出来的（控制台输出）

# Interrupt硬件部分
我们主要关注外部设备的中断，外部设备映射到内核内存的某处，类似于读写内存，通过向相应的设备地址执行load/store指令，我们就可以对例如UART的设备进行编程。

所有的设备都连接到处理器上，处理器通过PLIC（Platform Level Interrupt Control）来管理外设的中断。其流程为：
- PLIC会通知当前有一个待处理的中断
- 其中一个CPU核会Claim接收中断，这样PLIC就不会把中断发给其他的CPU处理
- CPU核处理完中断之后，CPU会通知PLIC
- PLIC将不再保存中断的信息

# 设备驱动概述
我们今天要看的是UART设备的驱动，代码在uart.c文件中。

通常来说，管理设备的代码称为驱动，所有的驱动都在内核中。如果我们查看代码的结构，我们可以发现大部分驱动都分为两个部分，bottom/top。
- bottom：通常是Interrupt handler。当一个中断送到了CPU，并且CPU设置接收这个中断，CPU会调用相应的Interrupt handler。Interrupt handler并不运行在任何特定进程的context中，它只是处理中断。
- top：是用户进程，或者内核其他部分调用的接口。对于UART来说，这里有read/write接口，这些接口可以被更高层级的代码调用。

通常情况下，驱动中会有一些队列（或者说buffer），top部分的代码会从队列中读写数据，而Interrupt handler（bottom部分）同时也会向队列中读写数据。这里的队列可以将并行运行的设备和CPU解耦开来。
![[Pasted image 20231001145529.png]]



