# C程序到汇编程序的转换
XV6操作系统是一个RISC-V的操作系统，虽然我们写的都是C程序，但很显然处理器是不会认识这些C程序的。因而我们需要将C程序编译成汇编语言，这个过程不是这门课的重点，所以我们忽略，就当作C程序变成了汇编语言并最终变成.o/.obj的二进制文件。

事实上在我们进行make qemu后，就会发现所有程序都进行了以下过程，我们的处理器处理的就是二进制文件。
![[Pasted image 20230919113454.png]]
多提一句，RISC-V使用自己的ISA，即自己的指令集，我们的编译实际上也是将C程序转成RISC-V汇编语言，这和X86汇编语言是不一样的。之后汇编也是将汇编指令转成对应的二进制指令，这些就是RISC-V的指令，这一点在组原课设里也可以得到验证。

# RISC-V vs x86
这一部分仅仅是了解性的内容，没什么好说的。

# gdb和汇编代码执行
这一部分展示如何用gdb观察汇编代码的执行，之前也讲过，不过我暂时还学不会，而且也好像用不到。

# RISC-V寄存器
从这一部分开始就是和Lab相关的部分了。

我们之前学习汇编也知道，汇编代码都是对寄存器进行操作的，一般都会把数据加载到寄存器上，然后进行操作。

当我们谈到寄存器，我们一般都是用ABI名。

a0到a7寄存器是用来作为函数的参数。如果一个函数有超过8个参数，我们就需要用内存了

第三列中，描述了各个寄存器的对应功能。

第四列中，Caller Saved寄存器在函数调用的时候不会保存，Callee Saved寄存器在函数调用的时候会保存。任何一个Caller Saved寄存器，作为调用方的函数要小心可能的数据可能的变化；任何一个Callee Saved寄存器，作为被调用方的函数要小心寄存器的值不会相应的变化。
![[Pasted image 20230919114851.png]]

# Stack
![[Pasted image 20230919184046.png]]
每一次我们调用一个函数，函数都会为自己创建一个Stack Frame，并且只给自己用。函数通过移动Stack Pointer来完成Stack Frame的空间分配。

对于Stack来说，是从高地址开始向低地址（图中从上到下）使用。所以栈总是向下增长。当我们想要创建一个新的Stack Frame的时候，总是对当前的Stack Pointer做减法。一个函数的Stack Frame包含了Return Address、保存的寄存器、本地变量、指向前一个Stack Frame的指针

SP（Stack Pointer），指向Stack的底部并代表了当前Stack Frame的位置
FP（Frame Pointer），指向当前Stack Frame的顶部

我们保存前一个Stack Frame的指针的原因是为了让我们能跳转回去。所以当前函数返回时，我们可以将前一个Frame Pointer存储到FP寄存器中。所以我们使用Frame Pointer来操纵我们的Stack Frames，并确保我们总是指向正确的函数。

# RVG调用协定
当在堆栈上传递两倍于指针字大小的基本参数时，它们是自然对齐的。当它们在整数寄存器中传递时，它们驻留在对齐的偶数号-奇数号寄存器对中，偶数寄存器保存最低有效位

在标准的RISC-V调用约定中，栈向下增长，栈指针始终保持16字节对齐



