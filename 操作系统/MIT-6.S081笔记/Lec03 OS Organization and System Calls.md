# 本节课主要内容
- Isolation。隔离性是设计操作系统组织结构的驱动力。
- Kernel和User mode。这两种模式用来隔离操作系统内核和用户应用程序。
- System calls。系统调用是你的应用程序能够转换到内核执行的基本方法，这样你的用户态应用程序才能使用内核服务。
- 最后我们会看到所有的这些是如何以一种简单的方式在XV6中实现。

# 操作系统的三个要求
1. 多路分时复用(multiplexing)。不论应用程序在执行什么操作，multiplexing都会迫使应用程序时不时的释放CPU，这样其他的应用程序才能运行。
2. 隔离。不同应用间需要有强隔离性，应用与操作系统间也要有强隔离性。
3. 交互。进程之间应当可以进行刻意为之的交互。

# 抽象系统资源（System calls）
为了实现强隔离， 最好禁止应用程序直接访问敏感的硬件资源，而是将资源抽象为服务。 Unix接口就是抽象资源的一个好方法。

例如：
1. Unix应用程序只通过文件系统的`open`、`read`、`write`和`close`系统调用与存储交互，而不是直接读写磁盘。
2. Unix进程使用`exec`来构建它们的内存映像，而不是直接与物理内存交互。这允许操作系统决定将一个进程放在内存中的哪里；
3. fork创建了进程。进程本身不是CPU，但是它们对应了CPU，它们使得你可以在CPU上运行计算任务。应用程序不能直接与CPU交互，只能与进程交互。
4. Unix在进程之间透明地切换硬件处理器，根据需要保存和恢复寄存器状态，这样应用程序就不必意识到多路复用的存在。即使是无限循环的应用程序也不会导致CPU无限占用。
5. Unix进程之间的许多交互形式都是通过文件描述符实现的。文件描述符不仅抽象了许多细节（例如，管道或文件中的数据存储在哪里），而且还以简化交互的方式进行了定义。

# User/Kernel mode
操作系统需要具备防御性，即操作系统需要能够应对恶意的应用程序。如果操作系统需要具备防御性，那么在应用程序和操作系统之间需要有一堵厚墙，并且操作系统可以在这堵墙上执行任何它想执行的策略。

通常我们需要硬件隔离来实现这样的防御性。一方面是User/Kernel mode，另一方面是page table或者虚拟内存（Virtual Memory）。后者将在之后课程讨论。

## CPU的三种模式
CPU为强隔离提供硬件支持。例如，RISC-V有三种CPU可以执行指令的模式：
1. 机器模式(Machine Mode)。在机器模式下执行的指令具有完全特权；CPU在机器模式下启动。机器模式主要用于配置计算机。Xv6在机器模式下执行很少的几行代码，然后更改为管理模式。
2. 管理模式(Supervisor Mode)，也即Kernel mode。在管理模式下，CPU被允许执行特权指令。如果用户模式下的应用程序试图执行特权指令，那么CPU不会执行该指令，而是切换到管理模式，以便管理模式代码可以终止应用程序，因为它做了它不应该做的事情。
3. 用户模式(User Mode)。当运行在user mode时，CPU只能运行普通权限的指令（unprivileged instructions）

## 简单看一下虚拟内存
虚拟内存（Virtual Memory）是硬件支持强隔离的第二个特性。基本上来说，处理器包含了page table，而page table将虚拟内存地址与物理内存地址做了对应。

每一个进程都会有自己独立的page table，这样的话，每一个进程只能访问出现在自己page table中的物理内存。操作系统会设置page table，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存，因为其他进程的物理内存都不在它的page table中。

基本上来说，page table定义了对于内存的视图，而每一个用户进程都有自己对于内存的独立视图。这给了我们非常强的内存隔离性。

## User/Kernel mode切换
想要调用内核函数的应用程序（例如xv6中的`read`系统调用）必须过渡到内核。所以需要有一种方式能够让应用程序可以将控制权转移给内核（Entering Kernel）。

在RISC-V中，有一个专门的指令用来实现这个功能，叫做ECALL。ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。

下图中通过一根竖线来区分用户空间和内核空间，左边是用户空间，右边是内核空间。在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是fork（后面会有相应的代码跟踪介绍）。
![Pasted image 20230905095547.png](Pasted%20image%2020230905095547.png)
这里需要澄清的是，用户空间和内核空间的界限是一个硬性的界限，用户不能直接调用内核中的fork代码。fork系统调用实际上就是调用ECALL指令，其参数就代表fork系统调用的数字，之后控制权到了syscall，它就会调用内核中的fork代码。

在内核侧，将会对该应用程序提出的系统调用进行检查，以确保该应用程序不是恶意的。

# 宏内核与微内核
宏内核：所有操作系统服务都在kernel mode中。
1. 首先，如果考虑Bug的话，这种方式不太好。在一个宏内核中，任何一个操作系统的Bug都有可能成为漏洞。因为我们现在在内核中运行了一个巨大的操作系统，出现Bug的可能性更大了。
2. 另一方面，如果你去看一个操作系统，它包含了各种各样的组成部分，比如说文件系统，虚拟内存，进程管理，这些都是操作系统内实现了特定功能的子模块。因而这样的集成能提供很好的性能。

微内核：在kernel mode中运行尽可能少的代码，将大部分的操作系统运行在内核之外。
1. 在user/kernel mode反复跳转带来的性能损耗。
2. 在一个类似宏内核的紧耦合系统，各个组成部分，例如文件系统和虚拟内存系统，可以很容易的共享page cache。而在微内核中，每个部分之间都很好的隔离开了，这种共享更难实现。进而导致更难在微内核中得到更高的性能。

# XV6 启动！
有点小难，没太看明白。
