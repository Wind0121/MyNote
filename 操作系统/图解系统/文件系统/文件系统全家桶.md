# 文件系统基本组成
## 索引节点
索引节点，也就是 _inode_，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、**数据在磁盘的位置**等等。索引节点是文件的**唯一**标识，它们之间一一对应，也同样都会被存储在硬盘中，所以**索引节点同样占用磁盘空间**。

每个文件都会有唯一的一个索引节点。

## 目录
**目录**也是一种文件，用于存储与其他目录项的层级关联关系，同样存放在磁盘中。

如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用**目录项**这个数据结构缓存在内存。

**目录项**，也就是 _dentry_，用来记录文件的名字、**索引节点指针**以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，**目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存**。可以简单理解为目录文件在内存中的**副本**。

## 打开文件表
![[Pasted image 20240104162006.png]]
操作系统在打开文件表中维护着打开文件的状态和信息：
- 文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；
- 文件打开计数器：打开文件表条目被使用的次数，如果为0就可以删除；
- 文件磁盘位置：实际上就是文件索引节点指针；
- 访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等）

# 文件的存储
文件存储指的是文件在磁盘上的存储方式，分为如下三种：
- 连续空间存储
- 链表存储（串联存储）
- 索引存储

## 连续空间存储
- 文件存放在磁盘「连续的」物理空间中，支持随机存取
- 文件头需要指定「起始块的位置」和「长度」
- 有「磁盘空间碎片」和「文件长度不易扩展」的缺陷
![[Pasted image 20240104162957.png]]

## 链表存储
链表存储可分为「**隐式链表**」和「**显式链接**」两种形式。

### 隐式链表
- 实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置
- 缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间
![[Pasted image 20240104163006.png]]

### 显式链表
- 把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，该表在整个磁盘仅设置一张，每个表项中存放链接指针，指向下一个数据块号
- 内存中的这样一个表格称为**文件分配表（_File Allocation Table，FAT_）**
![[Pasted image 20240104163315.png]]

## 索引存储
为每个⽂件建立逻辑块号和物理块号的对照表。文件由数据文件和索引表构成。这种文件称为索引文件。 可以通过查询索引表找到每个文件的第n块逻辑块对应物理块块号。

文件头需要包含指向「索引数据块」的指针，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。

索引的实现方式：
- 直接索引
- 一级索引
- 二级索引
- 多级索引
![[Pasted image 20240104163714.png]]

# 空闲空间管理
空闲空间管理负责整理空闲空间，并在需要分配空间时能快速找到适配的空间进行分配。通常有以下三种方法：
- 空闲表法
- 空闲链表法
- 位图法

## 空闲表法
空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是**连续分配**的。如下图：
![[Pasted image 20240104164356.png]]

这种方法适用于文件存储形式为连续存储的情况

## 空闲链表法
空闲链表法就是将所有空闲块用链表形式连接在一起，每一个空闲块里有一个指针指向下一个空闲块。

## 位图法
位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。
![[Pasted image 20231130115225.png]]

# 目录的存储
目录同样是一种文件，只不过普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。

目录文件中可以使用**列表**将文件信息一项一项地保存，也可以使用**哈希表**将文件名进行哈希计算，同时对应文件。

# 软链接与硬链接
**硬链接**是多个目录项中的「索引节点指针」指向一个文件，也就是指向同一个 inode。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。
![[Pasted image 20240104165203.png]]

**软链接**相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件。假如目标文件被删除，链接文件还是在的，只不过指向的文件找不到了而已。
![[Pasted image 20240104165252.png]]

# 文件I/O
![[Pasted image 20240104165939.png]]

## 直接与非直接 I/O
根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O：
- 直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。
- 非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。

## 阻塞与非阻塞I/O
**阻塞 I/O**，当用户程序执行 `read` ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，`read` 才会返回。
![[Pasted image 20240104170118.png]]

**非阻塞I/O**，当非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，`read` 调用才可以获取到结果。
![[Pasted image 20240104170154.png]]

**基于非阻塞I/O的多路复用**，当内核数据准备好时，再以事件通知应用程序进行操作，这样就不需要应用程序不停轮询。
![[Pasted image 20240104170243.png]]

## 异步I/O
**异步 I/O** 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。
![[Pasted image 20240104170316.png]]

## 小结
关于文件I/O可以看这个小故事：
![[Pasted image 20240104170450.png]]