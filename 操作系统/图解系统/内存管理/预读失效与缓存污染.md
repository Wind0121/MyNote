# Linux的缓存机制
在应用程序读取文件的数据的时候，Linux 操作系统是会对读取的文件数据进行缓存的，会缓存在文件系统中的 **Page Cache**。

Page Cache 属于内存空间里的数据，由于内存访问比磁盘访问快很多，在下一次访问相同的数据就不需要通过磁盘 I/O 了，命中缓存就直接返回数据即可。

# 预读机制
Linux 操作系统为基于 Page Cache 的读缓存机制提供**预读机制**，一个例子是：
- 应用程序只想读取磁盘上文件 A 的 offset 为 0-3KB 范围内的数据，由于磁盘的基本读写单位为 block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page 中装下。
- 但是操作系统出于**空间局部性原理**（靠近当前被访问数据的数据，在未来很大概率会被访问到），会选择将磁盘块 offset \[4KB,8KB)、\[8KB,12KB) 以及\[12KB,16KB) 都加载到内存，于是额外在内存中申请了 3 个 page；

# 预读失效
如果**这些被提前加载进来的页，并没有被访问**，相当于这个预读工作是白做了，这个就是**预读失效**，在传统的LRU算法中，这些没有被使用的预读页就会挤占热点数据，排在LRU链表的头部。

为了解决这个问题，Linux 操作系统实现两个了 LRU 链表：**活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）**。

有了这两个 LRU 链表后，**预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部**。如果预读的页一直没有被访问，就会从 inactive list 移除，这样就不会影响 active list 中的热点数据。

>在MySQL中，buffer pool采用在同一LRU链表中划分young区域和old区域的方式来解决预读失效的问题。

# 缓存污染
当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃 LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，**如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了**。

为了解决这个问题，我们需要提高进入活跃LRU链表的门槛，Linux操作系统保证在内存页被访问**第二次**的时候，才将页从 inactive list 升级到 active list 里。

通过提高门槛，就能避免在批量读取的情况下造成的缓存污染。

