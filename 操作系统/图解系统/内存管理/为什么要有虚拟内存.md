# 虚拟内存
物理内存是有限的，而操作系统又是多任务的操作系统，我们就需要让每个进程感觉自己拥有一块独立的内存，这就引出了虚拟内存。

**操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。**

如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。

操作系统有两种方式管理虚拟内存和物理内存之间的关系：
- 内存分段
- 内存分页

# 内存分段
程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。**不同的段是有不同的属性的，所以就用分段（_Segmentation_）的形式把这些段分离出来**

分段机制下的虚拟地址由两部分组成，**段选择因子**和**段内偏移量**：
- 段选择因子包含段号，段号可以在段表中找到该段的描述符，其中包含段基地址、段界限等信息
- 段内偏移值是该虚拟地址对应的物理地址相对于段基地址的偏移量
![[Pasted image 20231226111044.png]]

## 不足之处
内存分段会造成两个问题：
- 内存碎片：由于每个程序不同端的大小不同，占据的空间也就不同，等到端进行释放后，就可能出现碎片空间，且无法被其他程序端利用。
- 内存交换效率低：解决内存碎片就需要重新整理内存，通过在硬盘上设置交换空间，将内存中的段写到硬盘上，再重新分配内存空间，这样就实现了内存空间的整理。但这样做的问题就是读写硬盘效率低。

# 内存分页
为了解决内存分段的不足之处，我们可以采用内存分页的方式。将物理内存分成大小相同的页，每次分配物理内存以页为大小进行分配。之后我们就可以通过页表进行虚拟内存和物理内存之间的关联。

在分页机制下，虚拟地址分为两部分，**页号**和**页内偏移**。页号作为页表的索引，**页表**包含物理页每页所在**物理内存的基地址**，这个基地址与页内偏移的组合就形成了物理内存地址，见下图：
![[Pasted image 20231226113852.png]]
这样简单的一级分页可能导致一个问题，见下：
![[Pasted image 20231226114024.png]]

## 多级页表
我们通过多级映射的方式，减少不必要的页表项。
![[Pasted image 20231226114127.png]]

XV6中采用的是三级页表，现代64位操作系统通常使用四级页表。

## TLB（快表）
页表也是存储在内存中的，多级页表带来了多次的转换，这个过程也带来时间开销，因而我们可以借用Cache的思想设计一个页表映射的Cache，用于记住最常访问的页表项，这就是TLB。
![[Pasted image 20231226114408.png]]

# 段页式内存管理
内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为**段页式内存管理**。

段页式内存管理实现的方式：
- 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；
- 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；
这样，地址结构就由**段号、段内页号和页内位移**三部分组成。
![[Pasted image 20231226114654.png]]
段页式地址变换中要得到物理地址须经过三次内存访问：
- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号；
- 第三次将物理页号与页内位移组合，得到物理地址。

