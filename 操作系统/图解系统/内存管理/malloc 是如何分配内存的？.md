- [[#Linux 进程的内存分布长什么样？|Linux 进程的内存分布长什么样？]]
- [[#malloc 是如何分配内存的？|malloc 是如何分配内存的？]]
- [[#malloc() 分配的是物理内存吗？|malloc() 分配的是物理内存吗？]]
- [[#free 释放内存，会归还给操作系统吗？|free 释放内存，会归还给操作系统吗？]]
- [[#free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？|free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？]]
# Linux 进程的内存分布长什么样？
一个进程的虚拟空间分为用户虚拟空间和内核虚拟空间，如下图：
- 进程在用户态时，只能访问用户空间内存；
- 只有进入内核态后，才可以访问内核空间的内存；
![[Pasted image 20231227113049.png]]

每个进程的用户虚拟空间是独占的，但内核虚拟空间却都是关联的同一块物理地址，因为内核只有一个，也只占据一块物理内存，如下图：
![[Pasted image 20231227113208.png]]

内核空间的分布情况按下不表，我们来介绍用户空间的分布情况：
![[Pasted image 20231227113257.png]]
- 代码段，包括二进制可执行代码；
- 数据段，包括已初始化的静态常量和全局变量；
- BSS 段，包括未初始化的静态变量和全局变量；
- 堆段，包括动态分配的内存，从低地址开始向上增长；
- 文件映射段，包括动态库、共享内存等，从低地址开始向上增长；
- 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 `8 MB`。当然系统也提供了参数，以便我们自定义大小；

在这 6 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 `malloc()` 或者 `mmap()` ，就可以分别在堆和文件映射段动态分配内存。

# malloc 是如何分配内存的？
malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存，其有两种方式向操作系统申请内存：
- 方式一：通过 brk() 系统调用从堆分配内存
- 方式二：通过 mmap() 系统调用在文件映射区域分配内存；

方式一实现的方式很简单，就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间。如下图：
![[Pasted image 20231227113950.png]]

方式二通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。如下图：
![[Pasted image 20231227114004.png]]

malloc() 源码里默认定义了一个阈值：
- 如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；
- 如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；

# malloc() 分配的是物理内存吗？
不是的，**malloc() 分配的是虚拟内存**。只有当程序访问到已分配的虚拟内存，发现没有对应的物理页时，才会触发缺页中断，并分配实际的物理页。

# free 释放内存，会归还给操作系统吗？
- malloc 通过 **brk()** 方式申请的内存，free 释放内存的时候，**并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用**；
- malloc 通过 **mmap()** 方式申请的内存，free 释放内存的时候，**会把内存归还给操作系统，内存得到真正的释放**。

# free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？
malloc分配内存时，都会额外分配16字节的内存块头信息，当传入内存地址时，free函数会找到该地址左侧的内存块头信息，进而得知该内存块的大小。