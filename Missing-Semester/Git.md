# Git 基础 
**文件阶段**
看图即可
![[Pasted image 20230808094755.png]]
__获取仓库__
1. 本地初始化仓库 `git init`
2. 克隆现有仓库 `git clone <url> [fileto]`

__.git__
涉及到git的底层存储与数据模型，可以理解为存储了git仓库的索引和引用

**检查文件状态**
`git status`查看仓库中的哪些文件处于哪些状态

**跟踪新文件**
`git add <file>` 跟踪文件即给文件打上跟踪标记，同时添加到暂存区中

**暂存已修改文件**
`git add` 也用来将跟踪到的文件修改添加到暂存区中

**.gitignore**
用来告诉git忽略某些文件，即不用跟踪某些文件。也是一种dotfile

**显示差异**
`git diff` 有很多功能

**提交更新**
`git commit` 会提交所有暂存区中的东西，并需要提供提交信息

`git commit -a` 可以用来跳过暂存步骤，直接提交已经跟踪的文件，就不用先执行`git add` 来暂存文件了

**移除文件**
`git rm <file>` 会将文件从跟踪文件中移除，并将该文件从磁盘中删除
`git rm --cached <file>`  会将文件从跟踪文件中移除，但不会从磁盘中删除，仍保留在工作目录中

**移动文件**
`git rm` 可以用来修改文件名，然后`git`是可以跟踪这个修改的

**查看提交历史**
`git log` : 可以直接查看提交历史日志
`git log --all --graph --decorate`: 可视化历史记录（有向无环图）

**撤销修改提交**
`git commit --amend` 该命令主要是修改最后的提交.这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息
>当你在修补最后的提交时，与其说是修复旧提交，倒不如说是完全用一个 **新的提交** 替换旧的提交， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出现在仓库的历史中。
>修补提交最明显的价值是可以稍微改进你最后的提交，而不会让“啊，忘了添加一个文件”或者 “小修补，修正笔误”这种提交信息弄乱你的仓库历史。

**取消暂存的文件**
我们可能会想要一次只提交一个修改,因而就需要在暂存区只保留已给修改,那么移除暂存区中文件命令的方法就是 `git reset HEAD <file>` 
>`git reset` 确实是个危险的命令，如果加上了 `--hard` 选项则更是如此。 然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。

**撤销对文件的修改**
`git checkout -- <file>`将文件还原成上次提交时的样子
>请务必记得 `git checkout — <file>` 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。

如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 [Git 分支](https://git-scm.com/book/zh/v2/ch00/ch03-git-branching) 介绍保存进度与分支，这通常是更好的做法。

记住，在 Git 中任何 **已提交** 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 `--amend` 选项覆盖的提交也可以恢复 （阅读 [数据恢复](https://git-scm.com/book/zh/v2/ch00/_data_recovery) 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。

**查看远程仓库**
`git remote` 会显示已经配置的远程仓库

**添加远程仓库**
`git remote add <shortname> <url>` 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写

**从远程仓库中抓取和拉取**
`git fetch <remote>` : 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。

`git pull`: 如果你的当前分支设置了跟踪远程分支， 那么可以用 `git pull` 命令来自动抓取后合并该远程分支到当前分支

**推送到远程仓库**
`git push <remote> <branch>` 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。

**标签**
感觉暂时用不到

**别名**
感觉暂时用不到

# Git 分支
**分支创建**
`git branch <branch name>`

**分支切换**
`git checkout <branch name>` 切换到对应分支
注意：*检出* 就是指HEAD指针指向的分支，也就是当前所在的分支

可以使用`git checkout -b <branch name>` 来创建并切换到想要的分支

**常见分支处理模型**
[分支开发模型](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6)

**分支合并**
`git merge <branch name>` 

**合并冲突**
这一部分感觉还不是很清楚，而且也是水比较深的一块

**分支管理**
`git branch`可以查看当前已有分支，如下：
```console
$ git branch
  iss53
* master
  testing
```
其中`*`表示当前所在的分支，也就是检出的分支

`--merged` 与 `--no-merged` 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 `git branch --merged`：

```console
$ git branch --merged
  iss53
* master
```
*在这个列表中分支名字前没有 \* 号的分支通常可以使用 `git branch -d` 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。*

**分支开发工作流**
[常见分支开发工作流](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81)

**远程分支**
远程分支以 `<remote>/<branch>` 的形式命名

>“origin” 并无特殊含义
>远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 `git init` 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 `git clone` 时默认的远程仓库名字。 如果你运行 `git clone -o booyah`，那么你默认的远程分支名字将会是 `booyah/master`。

如果要与给定的远程仓库同步数据，运行 `git fetch <remote>` 命令，从中抓取本地没有的数据，并且更新本地数据库，移动 `origin/master` 指针到更新之后的位置。

如果希望和别人一起在名为 `serverfix` 的分支上工作，你可以像推送第一个分支那样推送它。 运行 `git push <remote> <branch>` 。如果并不想让远程仓库上的分支叫做 `serverfix`，可以运行 `git push origin serverfix:awesomebranch` 来将本地的 `serverfix` 分支推送到远程仓库上的 `awesomebranch` 分支。

**跟踪分支**
从一个远程跟踪分支检出一个本地分支会自动创建所谓的 *“跟踪分支”*（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 `git pull`，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。

当克隆一个仓库时，它通常会自动地创建一个跟踪 `origin/master` 的 `master` 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 `master` 分支。 最简单的实例就是像之前看到的那样，运行 `git checkout -b <branch> <remote>/<branch>`。 这是一个十分常用的操作所以 Git 提供了 `--track` 快捷方式：

```console
$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
```

![[Pasted image 20230809095304.png]]

**变基**
在 Git 中整合来自不同分支的修改主要有两种方法：`merge` 以及 `rebase`

它的原理是首先找到这两个分支（即当前分支 `experiment`、变基操作的目标基底分支 `master`） 的最近共同祖先 `C2`，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 `C3`, 最后以此将之前另存为临时文件的修改依序应用。

>请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。

**变基的风险**
>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。

感觉还不太明白这些风险的来源和解决方法，以后遇到实际情况再说吧。

# 分布式Git
**向一个项目贡献**
[Pro Git](https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E5%90%91%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E8%B4%A1%E7%8C%AE)这里讲了小型团队协作的流程，非常有启发性。

**维护项目**
难绷，感觉暂时还用不上






