# 构建系统
这一节主要讲的就是GNU Make，也就是make的用法和Makefile文件的编写。

Makefile是一门独立的语言，有点类似bash，但还是有所不同。

我们可以在Makefile编写一些指令，因而Makefile就像是一个脚本，而make指令就是调用这个脚本，然后我们就可以自动化执行一些指令，像是进行编译，或是生成依赖等。

总之Makefile真的是一个很重要的东西，之后还要看一下这个[文档](https://seisman.github.io/how-to-write-makefile/overview.html)

# 依赖管理
## 版本控制
大多数被其他项目所依赖的项目都会在每次发布新版本时创建一个_版本号_。通常看上去像 8.1.3 或 64.1.20192004。

不同项目所用的版本号其具体含义并不完全相同，但是一个相对比较常用的标准是[语义版本号](https://semver.org/)，这种版本号具有不同的语义，它的格式是这样的：主版本号.次版本号.补丁号。相关规则有：

- 如果新的版本没有改变 API，请将补丁号递增；
- 如果您添加了 API 并且该改动是向后兼容的，请将次版本号递增；
- 如果您修改了 API 但是它并不向后兼容，请将主版本号递增。

## 锁文件
锁文件列出了您当前每个依赖所对应的具体版本号。通常，您需要执行升级程序才能更新依赖的版本。这么做的原因有很多，例如避免不必要的重新编译、创建可复现的软件版本或禁止自动升级到最新版本（可能会包含 bug）。还有一种极端的依赖锁定叫做 _vendoring_，它会把您的依赖中的所有代码直接拷贝到您的项目中，这样您就能够完全掌控代码的任何修改，同时您也可以将自己的修改添加进去，不过这也意味着如果该依赖的维护者更新了某些代码，您也必须要自己去拉取这些更新。

# 持续集成系统
持续集成，或者叫做 CI 是一种雨伞术语（umbrella term，涵盖了一组术语的术语），它指的是那些“当您的代码变动时，自动运行的东西”

它们的工作原理都是类似的：您需要在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对。

目前为止，最常见的规则是：如果有人提交代码，执行测试套件。当这个事件被触发时，CI 提供方会启动一个（或多个）虚拟机，执行您制定的规则，并且通常会记录下相关的执行结果。

## 测试简介
多数的大型软件都有“测试套件”。您可能已经对测试的相关概念有所了解，但是我们觉得有些测试方法和测试术语还是应该再次提醒一下：

- 测试套件：所有测试的统称。
- 单元测试：一种“微型测试”，用于对某个封装的特性进行测试。
- 集成测试：一种“宏观测试”，针对系统的某一大部分进行，测试其不同的特性或组件是否能_协同_工作。
- 回归测试：一种实现特定模式的测试，用于保证之前引起问题的 bug 不会再次出现。
- 模拟（Mocking）: 使用一个假的实现来替换函数、模块或类型，屏蔽那些和测试不相关的内容。例如，您可能会“模拟网络连接” 或 “模拟硬盘”。

感觉大型项目中这种测试就很常见，像TinyKV就遇到了很多，既有整体的测试（make project2a）；也有单元的测试（一个个测试点）；也有模拟的出现，像project2a中不用考虑消息的发送，也就是说不用考虑上层的构建。

# 个人感想
这一部分讲的都是软件构建中的一些流程和工具，这都是需要在实战中历练的，像Makefile一定要好好学学才行，之后我们有空就学一下Makefile文档，目前先把Missing-Semester尽快学完。