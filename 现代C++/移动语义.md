# 左值与右值
1. 左值：
	- 有地址、数值、存储空间的值，往往长期存在； 
	- 左值是**由某种存储支持的变量**；
	- **左值有地址和值**，可以出现在赋值运算符左边或者右边。
2. 右值：
	- 是**临时量**，无地址（或者说有地址但访问不到，它只是一个临时量） 没有存储空间的短暂存在的值 。
3. 左值引用：
	- 左值引用仅仅接受左值，除非用了const兼容（ 非const的左值引用只接受左值 ） 所以C++常用**常量引用**。**因为它们兼容临时的右值和实际存在的左值变量**
4. 右值引用：
	- 右值引用不能绑定到左值，可以通过常引用或者右值引用延长右值的生命周期 “有名字的右值引用是左值”
	- 写法就是`&&`，双引用
5. 右值引用的优势：**优化**
	- 如果我们知道传入的是一个临时对象的话，那么我们就不需要担心它们是否活着，是否完整，是否拷贝。
	- 我们可以简单地偷它的资源，给到特定的对象，或者其他地方使用它们。因为我们知道它是暂时的，它不会存在很长时间。
	- 而如果如上使用const string& str，虽然可以兼容右值，但是却不能从这个字符串中窃取任何东西！因为这个str可能会在很多函数中使用，不可乱修改！（所以才加了const）
```cpp
void PrintName(std::string name) // 可接受左值和右值
{
    std::cout<<name<<std::endl;
}
void PrintName(std::string& name) // 只接受左值引用，不接受右值
{
    std::cout << name << std::endl;
}
void PrintName(const std::string& name) // 接受左值和右值，把右值当作const lvalue&
{
    std::cout << name << std::endl;
}
void PrintName(std::string&& name) // 接受右值引用
{
    std::cout << name << std::endl;
}
```


# 移动语义
为什么需要移动语义？
>很多时候我们只是单纯创建一些右值，然后赋给某个对象用作构造函数。这时候会出现的情况是：首先需要在main函数里创建这个右值对象，然后复制给这个对象相应的成员变量。 
>如果我们可以直接把这个右值变量**移动**到这个成员变量而不需要做一个额外的复制行为，**程序性能**就能**提高**。

# std::move与移动赋值操作符
1. 使用std::move，返回一个右值引用，可以将本来的copy操作变为move操作
2. 有时候我们想要将一个已经存在的对象移动给另一个已经存在的对象，就像下面这样
>**移动赋值**相当于把别的对象的资源都偷走，那如果移动到自己头上了就没必要自己偷自己 。 更重要的是**原来自己的资源一定要释放掉**，否则指向自己原来内容内存的指针就没了，这一片内存就泄露了！

