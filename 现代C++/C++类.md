# 概述
- 类的本质就是语法糖，用于将变量和方法（函数）组织在一起
- 类的使用可以让代码简洁，提高代码的可复用性
- 类成员分为public和private，其中private变量只能被类内部的方法使用

# class和struct的区别
- 从技术上讲，class默认为private，struct默认为public，其他没有任何区别
- 从历史上讲，struct是C的东西，C++是为了向后兼容才保留了struct
- 从使用上讲，struct通常只作为变量的集合，不会用于复杂的处理，也不会用于继承
- 从使用上讲，class才是C++用于面向对象编程的方式

# 构造函数
- 当创建对象的时候，构造函数被调用
- 构造函数最重要的作用就是初始化类
- 构造函数没有返回类型
- **构造函数的命名必须和类名一样**
- 如果你不指定构造函数，你仍然有一个构造函数，这叫做默认构造函数（default constructor），是默认就有的。但是，我们仍然可以删除该默认构造函数。
- 构造函数不会在你没有实例化对象的时候运行，所以如果你只是使用类的静态方法，构造函数是不会执行的
- 当你用new关键字创建对象实例的时候也会调用构造函数

# 析构函数
- 析构函数是在你销毁一个对象的时候运行
- 析构函数同时适用于栈和堆分配的内存
	- 如果你用new关键字创建一个对象（存在于堆上），然后你调用delete，析构函数就会被调用。  
	-  如果你只有基于栈的对象，当跳出作用域的时候这个对象会被删除，所以这时侯析构函数也会被调用。
- 构造函数和析构函数在声明和定义的唯一区别就是放在析构函数前面的波形符（~）
- **析构函数没有参数，不能被重载**，因此一个类只能有一个析构函数
- 不显式的定义析构函数，系统会调用默认析构函数

# 继承
- 当你创建了一个子类，它会包含父类的一切
- 继承给我们提供了这样的一种方式：把一系列类的所有通用的代码（功能）放到基类
- 派生类是通过对基类进行修改和扩充得到的，在派生类中，可以扩充新的成员变量和成员函数
- 派生类拥有基类的全部成员函数和成员变量，不论是private、protected、public。需要注意的是：在派生类的各个成员函数中，不能访问基类的private成员

# 虚函数
- 虚函数可以让我们在子类中重写方法
- 格式
```cpp
claee 父类名{
   //virtual + 函数
   virtual void GetName(){
       .....
   }
}
```
- 虚函数的例子，通常有三步
	- 定义基类，声明基类函数为 `virtual` 
	- 定义派生类(继承基类)，派生类实现了定义在基类的 `virtual` 函数
	- 声明基类指针，并指向派生类，调用`virtual`函数，此时虽然是基类指针，但调用的是派生类实现的基类`virtual` 函数

# 纯虚函数（接口）
- 防止派生类忘记实现虚函数，**纯虚函数使得派生类必须实现基类的虚函数**
- **声明方法**: 在基类中纯虚函数的方法的后面加 **=0**
```cpp
virtual void funtion()=0;
virtual std::string GetName() = 0;
```
- 纯虚函数与虚函数的区别在于，纯虚函数的基类中的`virtual`函数，只定义了，但不实现。实现交给派生类来做
- **只能实例化一个实现了所有纯虚函数的类**。**纯虚函数必须被实现**，然后我们才能创建这个类的实例
- 纯虚函数允许我们在基类中定义一个没有实现的函数，然后**强制子类**去实现该函数
- 在面向对象程序设计中，创建一个只包含未实现方法然后交由子类去实际实现功能的类是非常普遍的，这通常被称为接口。**接口就是一个只包含未实现的方法并作为一个模板的类**，并且由于此**接口类**实际上不包含方法实现，我们**无法实例化**这个类

# C++可见性
- 可见性是一个属于面向对象编程的概念，它指的是类的某些成员或方法实际上是否可见。可见性是指：谁能看到它们，谁能调用它们，谁能使用它们，所有这些东西
- 可见性是对程序实际运行方式、程序性能或类似的东西没影响。它只单纯的是语言层面的概念，让你能够写出更好的代码或者帮助你组织代码
- C++中有三个基础的可见修饰符（访问修饰符）：**private、protected、public**
	- **private**：只有**自己的类和它的友元**才能访问（继承的子类也不行，友元的意思就是可以允许你访问这个类的私有成员）
	- **protected**：这个**类以及它的所有派生类**都可以访问到这些成员。（但在main函数中new一个类就不可见，这其实是因为main**函数不是类的函数**，对main函数是不可访问的）
	- **public：谁都可见**

# 成员初始化列表
```cpp
Entity() : m_Name("Unknow"), m_Score(0)
  	{
  	}
```
- 注意：在成员初始化列表里需要按成员变量定义的顺序写。这很重要，因为不管你怎么写初始化列表，它都会按照定义类的顺序进行初始化
- 使用成员初始化列表的原因：代码风格简洁，**避免性能浪费**
- 我们应该尽可能使用成员初始化列表来进行类成员初始化，一方面可以使构造函数内部简介，用于做其他的事情，另一方面是真的关乎性能。

# 创建并初始化C++对象
- 基本上，当我们编写了一个类并且到了我们实际开始使用该类的时候，就需要实例化它(除非它是完全静态的类)
- 实例化类有两种选择，可以放在栈上，也可以放在堆上
- 基本的初始化就是栈分配，用new就是堆分配

# 隐式转换与explicit关键字
## 隐式转换
```cpp
#include <iostream>

class Entity
{
private:
    std::string m_Name;
    int m_Age;
public:
    Entity(const std::string& name)
        : m_Name(name), m_Age(-1) {}

    Entity(int age)
        : m_Name("Unknown"), m_Age(age) {}
};

int main()
{
    Entity test1("lk");
    Entity test2(23); 
    Entity test3 = "lk"; //error!只能进行一次隐式转换
    Entity test4 = std::string("lk");
    Entity test5 = 23; //发生隐式转换
    
    std::cin.get();
}
```
- **隐式转换只能进行一次**
- test1、test2都是直接调用构造函数
- test4、test5都是进行了一次隐式转换，即先将参数构造成Entity，再将Entity赋值给变量
- 对于test3，`Entity test3 = "lk";`会报错，原因是**只能进行一次隐式转换**，`"lk"`是`const char`数组，这里需要先转换为`std::string`，再从string转换为Entity变量，两次隐式转换是不行的，所以会报错。
- 我们在实际应用中应尽可能避免隐式转换

## explicit关键字
- explicit是用来当你想要显示地调用构造函数，而不是让C++编译器隐式地把任何整形转换成Entity
- 如果你在构造函数前面加上explicit，这意味着这个构造函数不会进行隐式转换

# C++的拷贝与拷贝构造函数
1. 拷贝构造函数的格式：
```cpp
//声明：
T(const T& var);
//定义
T(const T& var){
    //函数体，进行深拷贝 分配空间放副本
}
//不使用拷贝函数，禁止赋值
T(const T& var) = delete;
```
2. 每当你编写一个变量被赋值另一个变量的代码时，你**总是**在复制。在指针的情况下，你在复制指针，也就是内存地址，而不是指针指向的实际内容
3. 浅拷贝只拷贝基本数据类型（非指针变量）
>浅拷贝的问题是如果对象中变量带有指针（或引用）,则会发生错误.因为**两个指针指向同一个内存**,**一个对象修改,另一个对象的值也被更改了.** 当在**析构**的时候,会**发生两次free (double free)同一个内存，造成错误**.
4. 拷贝构造函数：进行深拷贝


